
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">grabarr/internal/api/handlers.go (32.3%)</option>
				
				<option value="file1">grabarr/internal/api/jobs.go (85.1%)</option>
				
				<option value="file2">grabarr/internal/api/middleware.go (100.0%)</option>
				
				<option value="file3">grabarr/internal/api/sync.go (98.4%)</option>
				
				<option value="file4">grabarr/internal/api/system.go (100.0%)</option>
				
				<option value="file5">grabarr/internal/api/web.go (0.0%)</option>
				
				<option value="file6">grabarr/internal/config/config.go (48.7%)</option>
				
				<option value="file7">grabarr/internal/executor/rclone.go (96.8%)</option>
				
				<option value="file8">grabarr/internal/models/job.go (95.7%)</option>
				
				<option value="file9">grabarr/internal/models/sync.go (95.1%)</option>
				
				<option value="file10">grabarr/internal/monitor/monitor.go (0.0%)</option>
				
				<option value="file11">grabarr/internal/notifications/pushover.go (0.0%)</option>
				
				<option value="file12">grabarr/internal/queue/queue.go (54.7%)</option>
				
				<option value="file13">grabarr/internal/rclone/client.go (93.0%)</option>
				
				<option value="file14">grabarr/internal/repository/repository.go (79.5%)</option>
				
				<option value="file15">grabarr/internal/services/sync.go (76.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package api

import (
        "encoding/json"
        "log/slog"
        "net/http"

        "grabarr/internal/config"
        "grabarr/internal/interfaces"

        "github.com/gorilla/mux"
)

type Handlers struct {
        queue       interfaces.JobQueue
        monitor     interfaces.ResourceMonitor
        config      *config.Config
        syncService interfaces.SyncService
}

type APIResponse struct {
        Success bool        `json:"success"`
        Data    interface{} `json:"data,omitempty"`
        Error   string      `json:"error,omitempty"`
        Message string      `json:"message,omitempty"`
}


func NewHandlers(jobQueue interfaces.JobQueue, monitor interfaces.ResourceMonitor, cfg *config.Config, syncService interfaces.SyncService) *Handlers <span class="cov8" title="1">{
        return &amp;Handlers{
                queue:       jobQueue,
                monitor:     monitor,
                config:      cfg,
                syncService: syncService,
        }
}</span>

func (h *Handlers) RegisterRoutes(r *mux.Router) <span class="cov0" title="0">{
        // Web UI routes (serve before API to avoid conflicts)
        h.registerWebRoutes(r)

        api := r.PathPrefix("/api/v1").Subrouter()

        // Job management endpoints
        api.HandleFunc("/jobs", h.CreateJob).Methods("POST")
        api.HandleFunc("/jobs", h.GetJobs).Methods("GET")
        api.HandleFunc("/jobs/{id:[0-9]+}", h.GetJob).Methods("GET")
        api.HandleFunc("/jobs/{id:[0-9]+}", h.DeleteJob).Methods("DELETE")
        api.HandleFunc("/jobs/{id:[0-9]+}/cancel", h.CancelJob).Methods("POST")
        api.HandleFunc("/jobs/summary", h.GetJobSummary).Methods("GET")

        // Sync endpoints
        api.HandleFunc("/sync", h.CreateSync).Methods("POST")
        api.HandleFunc("/sync", h.GetSyncs).Methods("GET")
        api.HandleFunc("/sync/{id:[0-9]+}", h.GetSync).Methods("GET")
        api.HandleFunc("/sync/{id:[0-9]+}/cancel", h.CancelSync).Methods("POST")
        api.HandleFunc("/sync/summary", h.GetSyncSummary).Methods("GET")

        // System endpoints
        api.HandleFunc("/health", h.HealthCheck).Methods("GET")
        api.HandleFunc("/metrics", h.GetMetrics).Methods("GET")
        api.HandleFunc("/status", h.GetStatus).Methods("GET")

        // Add CORS middleware
        api.Use(corsMiddleware)
        api.Use(loggingMiddleware)
        api.Use(jsonContentTypeMiddleware)
}</span>


func (h *Handlers) writeSuccess(w http.ResponseWriter, statusCode int, data interface{}, message string) <span class="cov8" title="1">{
        w.WriteHeader(statusCode)
        response := APIResponse{
                Success: true,
                Data:    data,
                Message: message,
        }

        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                slog.Error("failed to encode response", "error", err)
        }</span>
}

func (h *Handlers) writeError(w http.ResponseWriter, statusCode int, message string, err error) <span class="cov8" title="1">{
        w.WriteHeader(statusCode)
        response := APIResponse{
                Success: false,
                Error:   message,
        }

        if err != nil </span><span class="cov8" title="1">{
                slog.Error("API error", "message", message, "error", err)
        }</span> else<span class="cov8" title="1"> {
                slog.Warn("API error", "message", message)
        }</span>

        <span class="cov8" title="1">if jsonErr := json.NewEncoder(w).Encode(response); jsonErr != nil </span><span class="cov0" title="0">{
                slog.Error("failed to encode error response", "error", jsonErr)
        }</span>
}

</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "grabarr/internal/models"

        "github.com/gorilla/mux"
)

type CreateJobRequest struct {
        Name          string            `json:"name"`
        RemotePath    string            `json:"remote_path"`
        Priority      int               `json:"priority,omitempty"`
        MaxRetries    int               `json:"max_retries,omitempty"`
        EstimatedSize int64             `json:"estimated_size,omitempty"`
        Metadata      models.JobMetadata `json:"metadata,omitempty"`
}

func (h *Handlers) CreateJob(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req CreateJobRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusBadRequest, "Invalid JSON payload", err)
                return
        }</span>

        // Validate required fields
        <span class="cov8" title="1">if req.Name == "" </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusBadRequest, "job name is required", nil)
                return
        }</span>
        <span class="cov8" title="1">if req.RemotePath == "" </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusBadRequest, "remote_path is required", nil)
                return
        }</span>

        // Check category filtering
        <span class="cov8" title="1">downloadsConfig := h.config.GetDownloads()
        if len(downloadsConfig.AllowedCategories) &gt; 0 </span><span class="cov8" title="1">{
                category := req.Metadata.Category
                if category == "" || !contains(downloadsConfig.AllowedCategories, category) </span><span class="cov8" title="1">{
                        h.writeError(w, http.StatusBadRequest,
                                fmt.Sprintf("category '%s' not allowed. Allowed categories: %v",
                                        category, downloadsConfig.AllowedCategories), nil)
                        return
                }</span>
        }

        // Create job model
        <span class="cov8" title="1">job := &amp;models.Job{
                Name:          req.Name,
                RemotePath:    req.RemotePath,
                LocalPath:     downloadsConfig.LocalPath,
                Priority:      req.Priority,
                MaxRetries:    req.MaxRetries,
                EstimatedSize: req.EstimatedSize,
                Metadata:      req.Metadata,
                Status:        models.JobStatusQueued,
                Progress: models.JobProgress{
                        LastUpdateTime: time.Now(),
                },
        }

        // Enqueue the job
        if err := h.queue.Enqueue(job); err != nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusInternalServerError, "Failed to enqueue job", err)
                return
        }</span>

        <span class="cov8" title="1">h.writeSuccess(w, http.StatusCreated, job, "Job created successfully")</span>
}

func (h *Handlers) GetJobs(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        query := r.URL.Query()

        filter := models.JobFilter{}

        // Parse status filter
        if statusStr := query.Get("status"); statusStr != "" </span><span class="cov8" title="1">{
                filter.Status = []models.JobStatus{models.JobStatus(statusStr)}
        }</span>

        // Parse category filter
        <span class="cov8" title="1">if category := query.Get("category"); category != "" </span><span class="cov8" title="1">{
                filter.Category = category
        }</span>

        // Parse priority filters
        <span class="cov8" title="1">if minPriorityStr := query.Get("min_priority"); minPriorityStr != "" </span><span class="cov0" title="0">{
                if minPriority, err := strconv.Atoi(minPriorityStr); err == nil </span><span class="cov0" title="0">{
                        filter.MinPriority = &amp;minPriority
                }</span>
        }
        <span class="cov8" title="1">if maxPriorityStr := query.Get("max_priority"); maxPriorityStr != "" </span><span class="cov0" title="0">{
                if maxPriority, err := strconv.Atoi(maxPriorityStr); err == nil </span><span class="cov0" title="0">{
                        filter.MaxPriority = &amp;maxPriority
                }</span>
        }

        // Parse pagination
        <span class="cov8" title="1">if limitStr := query.Get("limit"); limitStr != "" </span><span class="cov8" title="1">{
                if limit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; limit &gt; 0 &amp;&amp; limit &lt;= 1000 </span><span class="cov8" title="1">{
                        filter.Limit = limit
                }</span> else<span class="cov0" title="0"> {
                        filter.Limit = 50 // Default limit
                }</span>
        } else<span class="cov8" title="1"> {
                filter.Limit = 50
        }</span>

        <span class="cov8" title="1">if offsetStr := query.Get("offset"); offsetStr != "" </span><span class="cov8" title="1">{
                if offset, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; offset &gt;= 0 </span><span class="cov8" title="1">{
                        filter.Offset = offset
                }</span>
        }

        // Parse sorting
        <span class="cov8" title="1">if sortBy := query.Get("sort_by"); sortBy != "" </span><span class="cov0" title="0">{
                filter.SortBy = sortBy
        }</span>
        <span class="cov8" title="1">if sortOrder := query.Get("sort_order"); sortOrder != "" </span><span class="cov0" title="0">{
                filter.SortOrder = sortOrder
        }</span>

        <span class="cov8" title="1">jobs, err := h.queue.GetJobs(filter)
        if err != nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusInternalServerError, "Failed to get jobs", err)
                return
        }</span>

        <span class="cov8" title="1">h.writeSuccess(w, http.StatusOK, jobs, "")</span>
}

func (h *Handlers) GetJob(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        id, err := strconv.ParseInt(vars["id"], 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusBadRequest, "Invalid job ID", err)
                return
        }</span>

        <span class="cov8" title="1">job, err := h.queue.GetJob(id)
        if err != nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusNotFound, "Job not found", err)
                return
        }</span>

        <span class="cov8" title="1">h.writeSuccess(w, http.StatusOK, job, "")</span>
}

func (h *Handlers) DeleteJob(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        id, err := strconv.ParseInt(vars["id"], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Invalid job ID", err)
                return
        }</span>

        <span class="cov8" title="1">if err := h.queue.CancelJob(id); err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusInternalServerError, "Failed to delete job", err)
                return
        }</span>

        <span class="cov8" title="1">h.writeSuccess(w, http.StatusOK, nil, "Job deleted successfully")</span>
}

func (h *Handlers) CancelJob(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        id, err := strconv.ParseInt(vars["id"], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                h.writeError(w, http.StatusBadRequest, "Invalid job ID", err)
                return
        }</span>

        <span class="cov8" title="1">if err := h.queue.CancelJob(id); err != nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusInternalServerError, "Failed to cancel job", err)
                return
        }</span>

        <span class="cov8" title="1">h.writeSuccess(w, http.StatusOK, nil, "Job cancelled successfully")</span>
}

func (h *Handlers) GetJobSummary(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        summary, err := h.queue.GetSummary()
        if err != nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusInternalServerError, "Failed to get job summary", err)
                return
        }</span>

        <span class="cov8" title="1">h.writeSuccess(w, http.StatusOK, summary, "")</span>
}

// Helper function to check if a slice contains a string
func contains(slice []string, item string) bool <span class="cov8" title="1">{
        for _, s := range slice </span><span class="cov8" title="1">{
                if s == item </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "log/slog"
        "net/http"
        "time"
)

// Middleware functions
func corsMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

                if r.Method == "OPTIONS" </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusNoContent)
                        return
                }</span>

                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        })
}

func loggingMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                start := time.Now()

                // Create a custom ResponseWriter to capture the status code
                rw := &amp;responseWriter{ResponseWriter: w, statusCode: http.StatusOK}

                next.ServeHTTP(rw, r)

                duration := time.Since(start)

                slog.Info("HTTP request",
                        "method", r.Method,
                        "path", r.URL.Path,
                        "status", rw.statusCode,
                        "duration", duration.String(),
                        "user_agent", r.UserAgent(),
                        "remote_addr", r.RemoteAddr,
                )
        }</span>)
}

func jsonContentTypeMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                w.Header().Set("Content-Type", "application/json")
                next.ServeHTTP(w, r)
        }</span>)
}

type responseWriter struct {
        http.ResponseWriter
        statusCode int
}

func (rw *responseWriter) WriteHeader(code int) <span class="cov8" title="1">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
        "encoding/json"
        "net/http"
        "strconv"

        "grabarr/internal/models"

        "github.com/gorilla/mux"
)

type CreateSyncRequest struct {
        RemotePath string `json:"remote_path"`
}

func (h *Handlers) CreateSync(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req CreateSyncRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusBadRequest, "Invalid JSON payload", err)
                return
        }</span>

        // Validate required fields
        <span class="cov8" title="1">if req.RemotePath == "" </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusBadRequest, "remote_path is required", nil)
                return
        }</span>

        // Start the sync
        <span class="cov8" title="1">syncJob, err := h.syncService.StartSync(r.Context(), req.RemotePath)
        if err != nil </span><span class="cov8" title="1">{
                if err.Error() == "maximum concurrent syncs (1) reached, please wait for existing sync to complete" </span><span class="cov8" title="1">{
                        h.writeError(w, http.StatusConflict, err.Error(), nil)
                }</span> else<span class="cov8" title="1"> {
                        h.writeError(w, http.StatusInternalServerError, "Failed to start sync", err)
                }</span>
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">h.writeSuccess(w, http.StatusCreated, syncJob, "Sync started successfully")</span>
}

func (h *Handlers) GetSyncs(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        query := r.URL.Query()

        filter := models.SyncFilter{}

        // Parse status filter
        if statusStr := query.Get("status"); statusStr != "" </span><span class="cov8" title="1">{
                filter.Status = []models.SyncStatus{models.SyncStatus(statusStr)}
        }</span>

        // Parse pagination
        <span class="cov8" title="1">if limitStr := query.Get("limit"); limitStr != "" </span><span class="cov8" title="1">{
                if limit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; limit &gt; 0 &amp;&amp; limit &lt;= 1000 </span><span class="cov8" title="1">{
                        filter.Limit = limit
                }</span> else<span class="cov0" title="0"> {
                        filter.Limit = 50 // Default limit
                }</span>
        } else<span class="cov8" title="1"> {
                filter.Limit = 50
        }</span>

        <span class="cov8" title="1">if offsetStr := query.Get("offset"); offsetStr != "" </span><span class="cov8" title="1">{
                if offset, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; offset &gt;= 0 </span><span class="cov8" title="1">{
                        filter.Offset = offset
                }</span>
        }

        // Parse sorting
        <span class="cov8" title="1">if sortBy := query.Get("sort_by"); sortBy != "" </span><span class="cov8" title="1">{
                filter.SortBy = sortBy
        }</span>
        <span class="cov8" title="1">if sortOrder := query.Get("sort_order"); sortOrder != "" </span><span class="cov8" title="1">{
                filter.SortOrder = sortOrder
        }</span>

        <span class="cov8" title="1">syncs, err := h.syncService.GetSyncJobs(filter)
        if err != nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusInternalServerError, "Failed to get syncs", err)
                return
        }</span>

        <span class="cov8" title="1">h.writeSuccess(w, http.StatusOK, syncs, "")</span>
}

func (h *Handlers) GetSync(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        id, err := strconv.ParseInt(vars["id"], 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusBadRequest, "Invalid sync ID", err)
                return
        }</span>

        <span class="cov8" title="1">syncJob, err := h.syncService.GetSyncJob(id)
        if err != nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusNotFound, "Sync not found", err)
                return
        }</span>

        <span class="cov8" title="1">h.writeSuccess(w, http.StatusOK, syncJob, "")</span>
}

func (h *Handlers) CancelSync(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        id, err := strconv.ParseInt(vars["id"], 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusBadRequest, "Invalid sync ID", err)
                return
        }</span>

        <span class="cov8" title="1">if err := h.syncService.CancelSync(r.Context(), id); err != nil </span><span class="cov8" title="1">{
                if err.Error() == "sync job is not active" </span><span class="cov8" title="1">{
                        h.writeError(w, http.StatusBadRequest, err.Error(), nil)
                }</span> else<span class="cov8" title="1"> if err.Error() == "sync job not found" </span><span class="cov8" title="1">{
                        h.writeError(w, http.StatusNotFound, err.Error(), nil)
                }</span> else<span class="cov8" title="1"> {
                        h.writeError(w, http.StatusInternalServerError, "Failed to cancel sync", err)
                }</span>
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">h.writeSuccess(w, http.StatusOK, nil, "Sync cancelled successfully")</span>
}

func (h *Handlers) GetSyncSummary(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        summary, err := h.syncService.GetSyncSummary()
        if err != nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusInternalServerError, "Failed to get sync summary", err)
                return
        }</span>

        <span class="cov8" title="1">h.writeSuccess(w, http.StatusOK, summary, "")</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package api

import (
        "net/http"
        "time"
)

var startTime = time.Now()

func (h *Handlers) HealthCheck(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        health := map[string]interface{}{
                "status":    "healthy",
                "timestamp": time.Now().UTC(),
                "uptime":    time.Since(startTime).String(),
                "version":   "1.0.0", // TODO: Get from build info
        }

        // Check resource status
        if h.monitor != nil </span><span class="cov8" title="1">{
                resourceStatus := h.monitor.GetResourceStatus()
                health["resources"] = resourceStatus
        }</span>

        <span class="cov8" title="1">h.writeSuccess(w, http.StatusOK, health, "Service is healthy")</span>
}

func (h *Handlers) GetMetrics(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if h.monitor == nil </span><span class="cov8" title="1">{
                h.writeError(w, http.StatusServiceUnavailable, "Monitoring not available", nil)
                return
        }</span>

        <span class="cov8" title="1">metrics := h.monitor.GetMetrics()

        // Add job queue metrics
        summary, err := h.queue.GetSummary()
        if err == nil </span><span class="cov8" title="1">{
                metrics["jobs"] = summary
        }</span>

        <span class="cov8" title="1">h.writeSuccess(w, http.StatusOK, metrics, "")</span>
}

func (h *Handlers) GetStatus(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        status := map[string]interface{}{
                "service":   "grabarr",
                "version":   "1.0.0",
                "timestamp": time.Now().UTC(),
                "uptime":    time.Since(startTime).String(),
        }

        // Get job summary
        if summary, err := h.queue.GetSummary(); err == nil </span><span class="cov8" title="1">{
                status["jobs"] = summary
        }</span>

        // Get resource status
        <span class="cov8" title="1">if h.monitor != nil </span><span class="cov8" title="1">{
                status["resources"] = h.monitor.GetResourceStatus()
        }</span>

        <span class="cov8" title="1">h.writeSuccess(w, http.StatusOK, status, "")</span>
}</pre>
		
		<pre class="file" id="file5" style="display: none">package api

import (
        "fmt"
        "net/http"
        "os"
        "path/filepath"

        "github.com/gorilla/mux"
)

// registerWebRoutes sets up static file serving for the web UI
func (h *Handlers) registerWebRoutes(r *mux.Router) <span class="cov0" title="0">{
        // Determine web directory path
        webDir := "web/static"
        if _, err := os.Stat(webDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                // Try relative to binary location
                if execPath, err := os.Executable(); err == nil </span><span class="cov0" title="0">{
                        webDir = filepath.Join(filepath.Dir(execPath), "web", "static")
                }</span>
        }

        // Serve static files (CSS, JS, images)
        <span class="cov0" title="0">staticHandler := http.StripPrefix("/static/", http.FileServer(http.Dir(webDir)))
        r.PathPrefix("/static/").Handler(staticHandler)

        // Serve main dashboard at /dashboard
        r.HandleFunc("/dashboard", h.serveDashboard).Methods("GET")
        r.HandleFunc("/ui", h.serveDashboard).Methods("GET")</span>
}

// serveDashboard serves the main dashboard HTML page
func (h *Handlers) serveDashboard(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        webDir := "web/static"

        // Try different possible locations
        possiblePaths := []string{
                webDir,
                filepath.Join(".", webDir),
                filepath.Join("/app", webDir),
        }

        var indexPath string
        for _, dir := range possiblePaths </span><span class="cov0" title="0">{
                testPath := filepath.Join(dir, "index.html")
                if _, err := os.Stat(testPath); err == nil </span><span class="cov0" title="0">{
                        indexPath = testPath
                        break</span>
                }
        }

        <span class="cov0" title="0">if indexPath == "" </span><span class="cov0" title="0">{
                // If index.html doesn't exist, show a simple message with navigation
                w.Header().Set("Content-Type", "text/html")
                w.WriteHeader(http.StatusOK)
                w.Write([]byte(`
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Grabarr Web UI&lt;/title&gt;
    &lt;style&gt;
        body { font-family: sans-serif; max-width: 800px; margin: 50px auto; padding: 20px; }
        .links { margin-top: 30px; }
        .links a { display: inline-block; margin-right: 20px; padding: 10px 15px; background: #007bff; color: white; text-decoration: none; border-radius: 5px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Grabarr Web UI&lt;/h1&gt;
    &lt;p&gt;Web UI files not found, but the API is working!&lt;/p&gt;
    &lt;div class="links"&gt;
        &lt;a href="/api/v1/health"&gt;Health Check&lt;/a&gt;
        &lt;a href="/api/v1/status"&gt;System Status&lt;/a&gt;
        &lt;a href="/api/v1/jobs"&gt;View Jobs (JSON)&lt;/a&gt;
        &lt;a href="/api/v1/jobs/summary"&gt;Job Summary&lt;/a&gt;
    &lt;/div&gt;
    &lt;p&gt;&lt;strong&gt;Debug info:&lt;/strong&gt; Checked paths: ` + fmt.Sprintf("%v", possiblePaths) + `&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
                `))
                return
        }</span>

        <span class="cov0" title="0">http.ServeFile(w, r, indexPath)</span>
}</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import (
        "fmt"
        "log/slog"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/fsnotify/fsnotify"
        "gopkg.in/yaml.v3"
)

type Config struct {
        Server        ServerConfig        `yaml:"server"`
        Downloads     DownloadsConfig     `yaml:"downloads"`
        Rclone        RcloneConfig        `yaml:"rclone"`
        Resources     ResourcesConfig     `yaml:"resources"`
        Jobs          JobsConfig          `yaml:"jobs"`
        Database      DatabaseConfig      `yaml:"database"`
        Notifications NotificationsConfig `yaml:"notifications"`
        Logging       LoggingConfig       `yaml:"logging"`
        Monitoring    MonitoringConfig    `yaml:"monitoring"`

        mu       sync.RWMutex
        watchers []chan&lt;- struct{}
}

type ServerConfig struct {
        Port            int           `yaml:"port"`
        Host            string        `yaml:"host"`
        ShutdownTimeout time.Duration `yaml:"shutdown_timeout"`
}

type DownloadsConfig struct {
        LocalPath         string   `yaml:"local_path"`
        AllowedCategories []string `yaml:"allowed_categories"`
}

type RcloneConfig struct {
        RemoteName            string        `yaml:"remote_name"`
        ConfigFile            string        `yaml:"config_file"`
        BandwidthLimit        string        `yaml:"bandwidth_limit"`
        TransferTimeout       time.Duration `yaml:"transfer_timeout"`
        AdditionalArgs        []string      `yaml:"additional_args"`
        DaemonAddr            string        `yaml:"daemon_addr"`
}

type ResourcesConfig struct {
        Bandwidth BandwidthConfig `yaml:"bandwidth"`
        Disk      DiskConfig      `yaml:"disk"`
}

type BandwidthConfig struct {
        MaxUsagePercent int           `yaml:"max_usage_percent"`
        CheckInterval   time.Duration `yaml:"check_interval"`
}

type DiskConfig struct {
        CacheDrivePath    string        `yaml:"cache_drive_path"`
        CacheDriveMinFree string        `yaml:"cache_drive_min_free"`
        ArrayMinFree      string        `yaml:"array_min_free"`
        CheckInterval     time.Duration `yaml:"check_interval"`
}

type JobsConfig struct {
        MaxConcurrent          int           `yaml:"max_concurrent"`
        MaxRetries             int           `yaml:"max_retries"`
        RetryBackoffBase       time.Duration `yaml:"retry_backoff_base"`
        RetryBackoffMax        time.Duration `yaml:"retry_backoff_max"`
        CleanupCompletedAfter  time.Duration `yaml:"cleanup_completed_after"`
        CleanupFailedAfter     time.Duration `yaml:"cleanup_failed_after"`
}

type DatabaseConfig struct {
        Path string `yaml:"path"`
}

type NotificationsConfig struct {
        Pushover PushoverConfig `yaml:"pushover"`
}

type PushoverConfig struct {
        Token         string        `yaml:"token"`
        User          string        `yaml:"user"`
        Enabled       bool          `yaml:"enabled"`
        Priority      int           `yaml:"priority"`
        RetryInterval time.Duration `yaml:"retry_interval"`
        ExpireTime    time.Duration `yaml:"expire_time"`
}

type LoggingConfig struct {
        Level  string `yaml:"level"`
        Format string `yaml:"format"`
        File   string `yaml:"file"`
}

type MonitoringConfig struct {
        ResourceCheckInterval time.Duration `yaml:"resource_check_interval"`
}

var (
        globalConfig *Config
        configOnce   sync.Once
)

// Load loads configuration from file with environment variable expansion
func Load(configPath string) (*Config, error) <span class="cov8" title="1">{
        var err error
        configOnce.Do(func() </span><span class="cov8" title="1">{
                globalConfig, err = loadConfig(configPath)
                if err == nil &amp;&amp; globalConfig != nil </span><span class="cov8" title="1">{
                        go globalConfig.watchConfig(configPath)
                }</span>
        })
        <span class="cov8" title="1">return globalConfig, err</span>
}

// Get returns the global configuration instance
func Get() *Config <span class="cov0" title="0">{
        if globalConfig == nil </span><span class="cov0" title="0">{
                panic("configuration not loaded - call Load() first")</span>
        }
        <span class="cov0" title="0">return globalConfig</span>
}

func loadConfig(configPath string) (*Config, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        // Expand environment variables
        <span class="cov8" title="1">content := os.ExpandEnv(string(data))

        var config Config
        if err := yaml.Unmarshal([]byte(content), &amp;config); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to unmarshal config: %w", err)
        }</span>

        // Validate configuration
        <span class="cov8" title="1">if err := config.validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config validation failed: %w", err)
        }</span>

        // Ensure directories exist
        <span class="cov8" title="1">if err := config.ensureDirectories(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create directories: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;config, nil</span>
}

func (c *Config) validate() error <span class="cov8" title="1">{
        if c.Server.Port &lt;= 0 || c.Server.Port &gt; 65535 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid server port: %d", c.Server.Port)
        }</span>

        <span class="cov8" title="1">if c.Jobs.MaxConcurrent &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("max_concurrent must be greater than 0")
        }</span>

        <span class="cov8" title="1">if c.Jobs.MaxRetries &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("max_retries cannot be negative")
        }</span>

        <span class="cov8" title="1">if c.Notifications.Pushover.Enabled </span><span class="cov8" title="1">{
                if c.Notifications.Pushover.Token == "" || strings.HasPrefix(c.Notifications.Pushover.Token, "${") </span><span class="cov8" title="1">{
                        return fmt.Errorf("pushover token is required when notifications are enabled")
                }</span>
                <span class="cov0" title="0">if c.Notifications.Pushover.User == "" || strings.HasPrefix(c.Notifications.Pushover.User, "${") </span><span class="cov0" title="0">{
                        return fmt.Errorf("pushover user is required when notifications are enabled")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (c *Config) ensureDirectories() error <span class="cov8" title="1">{
        dirs := []string{
                filepath.Dir(c.Database.Path),
        }

        if c.Logging.File != "" </span><span class="cov0" title="0">{
                dirs = append(dirs, filepath.Dir(c.Logging.File))
        }</span>

        <span class="cov8" title="1">for _, dir := range dirs </span><span class="cov8" title="1">{
                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create directory %s: %w", dir, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// WatchForChanges registers a channel to receive notifications when config changes
func (c *Config) WatchForChanges() &lt;-chan struct{} <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        ch := make(chan struct{}, 1)
        c.watchers = append(c.watchers, ch)
        return ch
}</span>

func (c *Config) watchConfig(configPath string) <span class="cov8" title="1">{
        watcher, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("failed to create config watcher", "error", err)
                return
        }</span>
        <span class="cov8" title="1">defer watcher.Close()

        configDir := filepath.Dir(configPath)
        if err := watcher.Add(configDir); err != nil </span><span class="cov0" title="0">{
                slog.Error("failed to watch config directory", "error", err, "path", configDir)
                return
        }</span>

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                select </span>{
                case event, ok := &lt;-watcher.Events:<span class="cov8" title="1">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>

                        // Check if the config file was modified
                        <span class="cov8" title="1">if filepath.Base(event.Name) == filepath.Base(configPath) &amp;&amp;
                           (event.Has(fsnotify.Write) || event.Has(fsnotify.Create)) </span><span class="cov0" title="0">{
                                slog.Info("config file changed, reloading", "file", configPath)

                                // Small delay to ensure file write is complete
                                time.Sleep(100 * time.Millisecond)

                                if err := c.reload(configPath); err != nil </span><span class="cov0" title="0">{
                                        slog.Error("failed to reload config", "error", err)
                                }</span> else<span class="cov0" title="0"> {
                                        c.notifyWatchers()
                                }</span>
                        }

                case err, ok := &lt;-watcher.Errors:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">slog.Error("config watcher error", "error", err)</span>
                }
        }
}

func (c *Config) reload(configPath string) error <span class="cov0" title="0">{
        newConfig, err := loadConfig(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.mu.Lock()
        defer c.mu.Unlock()

        // Update all fields
        c.Server = newConfig.Server
        c.Rclone = newConfig.Rclone
        c.Resources = newConfig.Resources
        c.Jobs = newConfig.Jobs
        c.Database = newConfig.Database
        c.Notifications = newConfig.Notifications
        c.Logging = newConfig.Logging
        c.Monitoring = newConfig.Monitoring

        slog.Info("configuration reloaded successfully")
        return nil</span>
}

func (c *Config) notifyWatchers() <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        for _, watcher := range c.watchers </span><span class="cov0" title="0">{
                select </span>{
                case watcher &lt;- struct{}{}:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0"></span>
                        // Non-blocking send - if buffer is full, skip
                }
        }
}

// GetRClone returns a copy of the rclone configuration
func (c *Config) GetRClone() RcloneConfig <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.Rclone
}</span>

// GetJobs returns a copy of the jobs configuration
func (c *Config) GetJobs() JobsConfig <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.Jobs
}</span>

// GetServer returns a copy of the server configuration
func (c *Config) GetServer() ServerConfig <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.Server
}</span>

// GetDownloads returns a copy of the downloads configuration
func (c *Config) GetDownloads() DownloadsConfig <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.Downloads
}</span>

// GetResources returns a copy of the resources configuration
func (c *Config) GetResources() ResourcesConfig <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.Resources
}</span>

// GetDatabase returns a copy of the database configuration
func (c *Config) GetDatabase() DatabaseConfig <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.Database
}</span>

// GetNotifications returns a copy of the notifications configuration
func (c *Config) GetNotifications() NotificationsConfig <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.Notifications
}</span>

// GetLogging returns a copy of the logging configuration
func (c *Config) GetLogging() LoggingConfig <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.Logging
}</span>

// GetMonitoring returns a copy of the monitoring configuration
func (c *Config) GetMonitoring() MonitoringConfig <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.Monitoring
}</pre>
		
		<pre class="file" id="file7" style="display: none">package executor

import (
        "context"
        "fmt"
        "log/slog"
        "path/filepath"
        "strings"
        "time"

        "grabarr/internal/config"
        "grabarr/internal/interfaces"
        "grabarr/internal/models"
        "grabarr/internal/rclone"
)

type RCloneExecutor struct {
        config       *config.Config
        monitor      interfaces.ResourceChecker
        progressChan chan models.JobProgress
        client       interfaces.RCloneClient
}

func NewRCloneExecutor(cfg *config.Config, monitor interfaces.ResourceChecker) *RCloneExecutor <span class="cov8" title="1">{
        rcloneConfig := cfg.GetRClone()
        client := rclone.NewClient(fmt.Sprintf("http://%s", rcloneConfig.DaemonAddr))

        return &amp;RCloneExecutor{
                config:       cfg,
                monitor:      monitor,
                progressChan: make(chan models.JobProgress, 100),
                client:       client,
        }
}</span>

func (r *RCloneExecutor) Execute(ctx context.Context, job *models.Job) error <span class="cov8" title="1">{
        slog.Info("starting rclone HTTP execution", "job_id", job.ID, "name", job.Name)

        // Check if daemon is responsive
        if err := r.client.Ping(ctx); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("rclone daemon not responsive: %w", err)
        }</span>

        // Prepare the copy operation using universal filter approach
        <span class="cov8" title="1">srcFs, dstFs, filter := r.prepareCopyRequest(job)

        // Single copy operation - works for both files and directories!
        copyResp, err := r.client.Copy(ctx, srcFs, dstFs, filter)

        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to start copy operation: %w", err)
        }</span>

        <span class="cov8" title="1">slog.Info("copy operation started", "job_id", job.ID, "rclone_job_id", copyResp.JobID)

        // Monitor the job progress
        return r.monitorJob(ctx, job, copyResp.JobID)</span>
}

func (r *RCloneExecutor) prepareCopyRequest(job *models.Job) (string, string, map[string]interface{}) <span class="cov8" title="1">{
        rcloneConfig := r.config.GetRClone()

        // Always use parent directory as source
        parentDir := filepath.Dir(job.RemotePath)
        if parentDir == "." </span><span class="cov0" title="0">{
                parentDir = ""
        }</span>
        <span class="cov8" title="1">srcFs := rcloneConfig.RemoteName + ":" + parentDir + "/"

        // Local destination (ensure trailing slash)
        dstFs := job.LocalPath
        if !strings.HasSuffix(dstFs, "/") </span><span class="cov8" title="1">{
                dstFs += "/"
        }</span>

        // Universal filter that works for files and directories
        <span class="cov8" title="1">targetName := filepath.Base(job.RemotePath)
        filter := map[string]interface{}{
                "IncludeRule": []string{
                        targetName,      // Match exact file
                        targetName + "/**", // Match directory contents
                },
        }

        slog.Info("prepared copy request",
                "job_id", job.ID,
                "src_fs", srcFs,
                "dst_fs", dstFs,
                "target_name", targetName,
                "filter", filter)

        return srcFs, dstFs, filter</span>
}

func (r *RCloneExecutor) monitorJob(ctx context.Context, job *models.Job, rcloneJobID int64) error <span class="cov8" title="1">{
        ticker := time.NewTicker(1 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        // Stop the rclone job if context is cancelled
                        stopCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
                        defer cancel()
                        if err := r.client.StopJob(stopCtx, rcloneJobID); err != nil </span><span class="cov0" title="0">{
                                slog.Error("failed to stop rclone job", "job_id", job.ID, "rclone_job_id", rcloneJobID, "error", err)
                        }</span>
                        <span class="cov8" title="1">return ctx.Err()</span>

                case &lt;-ticker.C:<span class="cov8" title="1">
                        status, err := r.client.GetJobStatus(ctx, rcloneJobID)
                        if err != nil </span><span class="cov8" title="1">{
                                slog.Error("failed to get job status", "job_id", job.ID, "rclone_job_id", rcloneJobID, "error", err)
                                continue</span>
                        }

                        // Update progress
                        <span class="cov8" title="1">r.updateJobProgress(job, status)

                        // Check if job is finished
                        if status.Finished </span><span class="cov8" title="1">{
                                if !status.Success </span><span class="cov8" title="1">{
                                        return fmt.Errorf("rclone job failed: %s", status.Error)
                                }</span>
                                <span class="cov8" title="1">slog.Info("rclone job completed successfully", "job_id", job.ID, "rclone_job_id", rcloneJobID)
                                return nil</span>
                        }
                }
        }
}

func (r *RCloneExecutor) updateJobProgress(job *models.Job, status *models.RCloneJobStatus) <span class="cov8" title="1">{
        progress := models.JobProgress{
                LastUpdateTime: time.Now(),
        }

        // Extract progress information from status
        output := status.Output
        if output.TotalBytes &gt; 0 </span><span class="cov8" title="1">{
                progress.TotalBytes = output.TotalBytes
                progress.TransferredBytes = output.Bytes
                progress.Percentage = float64(output.Bytes) / float64(output.TotalBytes) * 100
        }</span>

        <span class="cov8" title="1">if output.TotalTransfers &gt; 0 </span><span class="cov8" title="1">{
                progress.FilesTotal = int(output.TotalTransfers)
                progress.FilesCompleted = int(output.Transfers)
        }</span>

        <span class="cov8" title="1">progress.TransferSpeed = int64(output.Speed)

        // Estimate ETA if we have transfer speed
        if output.Speed &gt; 0 &amp;&amp; output.TotalBytes &gt; 0 </span><span class="cov8" title="1">{
                remainingBytes := output.TotalBytes - output.Bytes
                etaSeconds := float64(remainingBytes) / output.Speed
                eta := time.Now().Add(time.Duration(etaSeconds) * time.Second)
                progress.ETA = &amp;eta
        }</span>

        // Update job progress
        <span class="cov8" title="1">job.UpdateProgress(progress)

        // Send progress update (non-blocking)
        select </span>{
        case r.progressChan &lt;- progress:<span class="cov8" title="1"></span>
        default:<span class="cov8" title="1"></span>
        }

        <span class="cov8" title="1">slog.Debug("updated job progress",
                "job_id", job.ID,
                "percentage", progress.Percentage,
                "transferred", progress.TransferredBytes,
                "total", progress.TotalBytes,
                "speed", progress.TransferSpeed)</span>
}

func (r *RCloneExecutor) GetProgressChannel() &lt;-chan models.JobProgress <span class="cov8" title="1">{
        return r.progressChan
}</span>

func (r *RCloneExecutor) CanExecute() bool <span class="cov8" title="1">{
        // Check if we have available resources
        return r.monitor.CanScheduleJob()
}</pre>
		
		<pre class="file" id="file8" style="display: none">package models

import (
        "database/sql/driver"
        "encoding/json"
        "fmt"
        "time"
)

type JobStatus string

const (
        JobStatusQueued    JobStatus = "queued"
        JobStatusPending   JobStatus = "pending"
        JobStatusRunning   JobStatus = "running"
        JobStatusCompleted JobStatus = "completed"
        JobStatusFailed    JobStatus = "failed"
        JobStatusCancelled JobStatus = "cancelled"
)

type Job struct {
        ID               int64             `json:"id" db:"id"`
        Name             string            `json:"name" db:"name"`
        RemotePath       string            `json:"remote_path" db:"remote_path"`
        LocalPath        string            `json:"local_path" db:"local_path"`
        Status           JobStatus         `json:"status" db:"status"`
        Priority         int               `json:"priority" db:"priority"`
        Retries          int               `json:"retries" db:"retries"`
        MaxRetries       int               `json:"max_retries" db:"max_retries"`
        ErrorMessage     string            `json:"error_message,omitempty" db:"error_message"`
        Progress         JobProgress       `json:"progress" db:"progress"`
        Metadata         JobMetadata       `json:"metadata" db:"metadata"`
        CreatedAt        time.Time         `json:"created_at" db:"created_at"`
        UpdatedAt        time.Time         `json:"updated_at" db:"updated_at"`
        StartedAt        *time.Time        `json:"started_at,omitempty" db:"started_at"`
        CompletedAt      *time.Time        `json:"completed_at,omitempty" db:"completed_at"`
        EstimatedSize    int64             `json:"estimated_size,omitempty" db:"estimated_size"`
        TransferredBytes int64             `json:"transferred_bytes" db:"transferred_bytes"`
        TransferSpeed    int64             `json:"transfer_speed,omitempty" db:"transfer_speed"`
}

type JobProgress struct {
        Percentage        float64   `json:"percentage"`
        TransferredBytes  int64     `json:"transferred_bytes"`
        TotalBytes        int64     `json:"total_bytes"`
        TransferSpeed     int64     `json:"transfer_speed"`
        ETA               *time.Time `json:"eta,omitempty"`
        CurrentFile       string    `json:"current_file,omitempty"`
        FilesCompleted    int       `json:"files_completed"`
        FilesTotal        int       `json:"files_total"`
        LastUpdateTime    time.Time `json:"last_update_time"`
}

type JobMetadata struct {
        QBittorrentHash string            `json:"qbittorrent_hash,omitempty"`
        Category        string            `json:"category,omitempty"`
        Tags            []string          `json:"tags,omitempty"`
        SourceIP        string            `json:"source_ip,omitempty"`
        UserAgent       string            `json:"user_agent,omitempty"`
        RCloneArgs      []string          `json:"rclone_args,omitempty"`
        ExtraFields     map[string]interface{} `json:"extra_fields,omitempty"`
}

type JobAttempt struct {
        ID           int64     `json:"id" db:"id"`
        JobID        int64     `json:"job_id" db:"job_id"`
        AttemptNum   int       `json:"attempt_num" db:"attempt_num"`
        Status       JobStatus `json:"status" db:"status"`
        ErrorMessage string    `json:"error_message,omitempty" db:"error_message"`
        StartedAt    time.Time `json:"started_at" db:"started_at"`
        EndedAt      *time.Time `json:"ended_at,omitempty" db:"ended_at"`
        LogData      string    `json:"log_data,omitempty" db:"log_data"`
}


// Database value methods for custom types
func (jp JobProgress) Value() (driver.Value, error) <span class="cov0" title="0">{
        return json.Marshal(jp)
}</span>

func (jp *JobProgress) Scan(value interface{}) error <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var bytes []byte
        switch v := value.(type) </span>{
        case []byte:<span class="cov8" title="1">
                bytes = v</span>
        case string:<span class="cov8" title="1">
                bytes = []byte(v)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("cannot scan %T into JobProgress", value)</span>
        }

        <span class="cov8" title="1">return json.Unmarshal(bytes, jp)</span>
}

func (jm JobMetadata) Value() (driver.Value, error) <span class="cov0" title="0">{
        return json.Marshal(jm)
}</span>

func (jm *JobMetadata) Scan(value interface{}) error <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var bytes []byte
        switch v := value.(type) </span>{
        case []byte:<span class="cov8" title="1">
                bytes = v</span>
        case string:<span class="cov8" title="1">
                bytes = []byte(v)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("cannot scan %T into JobMetadata", value)</span>
        }

        <span class="cov8" title="1">return json.Unmarshal(bytes, jm)</span>
}

// Helper methods
func (j *Job) IsActive() bool <span class="cov8" title="1">{
        return j.Status == JobStatusRunning || j.Status == JobStatusPending
}</span>

func (j *Job) IsCompleted() bool <span class="cov8" title="1">{
        return j.Status == JobStatusCompleted || j.Status == JobStatusFailed || j.Status == JobStatusCancelled
}</span>

func (j *Job) CanRetry() bool <span class="cov8" title="1">{
        return j.Status == JobStatusFailed &amp;&amp; j.Retries &lt; j.MaxRetries
}</span>

func (j *Job) UpdateProgress(progress JobProgress) <span class="cov8" title="1">{
        progress.LastUpdateTime = time.Now()
        j.Progress = progress
        j.TransferredBytes = progress.TransferredBytes
        j.TransferSpeed = progress.TransferSpeed
        j.UpdatedAt = time.Now()
}</span>

func (j *Job) MarkStarted() <span class="cov8" title="1">{
        now := time.Now()
        j.Status = JobStatusRunning
        j.StartedAt = &amp;now
        j.UpdatedAt = now
}</span>

func (j *Job) MarkCompleted() <span class="cov8" title="1">{
        now := time.Now()
        j.Status = JobStatusCompleted
        j.CompletedAt = &amp;now
        j.UpdatedAt = now
        j.Progress.Percentage = 100.0
}</span>

func (j *Job) MarkFailed(errorMsg string) <span class="cov8" title="1">{
        now := time.Now()
        j.Status = JobStatusFailed
        j.ErrorMessage = errorMsg
        j.UpdatedAt = now
}</span>

func (j *Job) MarkCancelled() <span class="cov8" title="1">{
        now := time.Now()
        j.Status = JobStatusCancelled
        j.UpdatedAt = now
}</span>

func (j *Job) IncrementRetry() <span class="cov8" title="1">{
        j.Retries++
        j.Status = JobStatusQueued
        j.UpdatedAt = time.Now()
        j.ErrorMessage = ""
}</span>

// JobFilter represents filtering options for job queries
type JobFilter struct {
        Status     []JobStatus `json:"status,omitempty"`
        Category   string      `json:"category,omitempty"`
        MinPriority *int       `json:"min_priority,omitempty"`
        MaxPriority *int       `json:"max_priority,omitempty"`
        Limit      int         `json:"limit,omitempty"`
        Offset     int         `json:"offset,omitempty"`
        SortBy     string      `json:"sort_by,omitempty"`
        SortOrder  string      `json:"sort_order,omitempty"`
}

// JobSummary represents aggregated job statistics
type JobSummary struct {
        TotalJobs      int `json:"total_jobs"`
        QueuedJobs     int `json:"queued_jobs"`
        PendingJobs    int `json:"pending_jobs"`
        RunningJobs    int `json:"running_jobs"`
        CompletedJobs  int `json:"completed_jobs"`
        FailedJobs     int `json:"failed_jobs"`
        CancelledJobs  int `json:"cancelled_jobs"`
}</pre>
		
		<pre class="file" id="file9" style="display: none">package models

import (
        "database/sql/driver"
        "encoding/json"
        "fmt"
        "time"
)

type SyncStatus string

const (
        SyncStatusQueued    SyncStatus = "queued"
        SyncStatusRunning   SyncStatus = "running"
        SyncStatusCompleted SyncStatus = "completed"
        SyncStatusFailed    SyncStatus = "failed"
        SyncStatusCancelled SyncStatus = "cancelled"
)

type SyncJob struct {
        ID               int64           `json:"id" db:"id"`
        RemotePath       string          `json:"remote_path" db:"remote_path"`
        LocalPath        string          `json:"local_path" db:"local_path"`
        Status           SyncStatus      `json:"status" db:"status"`
        ErrorMessage     string          `json:"error_message,omitempty" db:"error_message"`
        Progress         SyncProgress    `json:"progress" db:"progress"`
        Stats            SyncStats       `json:"stats" db:"stats"`
        CreatedAt        time.Time       `json:"created_at" db:"created_at"`
        UpdatedAt        time.Time       `json:"updated_at" db:"updated_at"`
        StartedAt        *time.Time      `json:"started_at,omitempty" db:"started_at"`
        CompletedAt      *time.Time      `json:"completed_at,omitempty" db:"completed_at"`
        RCloneJobID      *int64          `json:"rclone_job_id,omitempty" db:"rclone_job_id"`
}

type SyncProgress struct {
        Percentage        float64   `json:"percentage"`
        TransferredBytes  int64     `json:"transferred_bytes"`
        TotalBytes        int64     `json:"total_bytes"`
        TransferSpeed     int64     `json:"transfer_speed"`
        ETA               *time.Time `json:"eta,omitempty"`
        CurrentFile       string    `json:"current_file,omitempty"`
        FilesCompleted    int       `json:"files_completed"`
        FilesTotal        int       `json:"files_total"`
        LastUpdateTime    time.Time `json:"last_update_time"`
}

type SyncStats struct {
        FilesTransferred int   `json:"files_transferred"`
        FilesSkipped     int   `json:"files_skipped"`
        FilesErrored     int   `json:"files_errored"`
        BytesTransferred int64 `json:"bytes_transferred"`
        TotalFiles       int   `json:"total_files"`
        TotalBytes       int64 `json:"total_bytes"`
}

// Database value methods for custom types
func (sp SyncProgress) Value() (driver.Value, error) <span class="cov0" title="0">{
        return json.Marshal(sp)
}</span>

func (sp *SyncProgress) Scan(value interface{}) error <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var bytes []byte
        switch v := value.(type) </span>{
        case []byte:<span class="cov8" title="1">
                bytes = v</span>
        case string:<span class="cov8" title="1">
                bytes = []byte(v)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("cannot scan %T into SyncProgress", value)</span>
        }

        <span class="cov8" title="1">return json.Unmarshal(bytes, sp)</span>
}

func (ss SyncStats) Value() (driver.Value, error) <span class="cov0" title="0">{
        return json.Marshal(ss)
}</span>

func (ss *SyncStats) Scan(value interface{}) error <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var bytes []byte
        switch v := value.(type) </span>{
        case []byte:<span class="cov8" title="1">
                bytes = v</span>
        case string:<span class="cov8" title="1">
                bytes = []byte(v)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("cannot scan %T into SyncStats", value)</span>
        }

        <span class="cov8" title="1">return json.Unmarshal(bytes, ss)</span>
}

// Helper methods
func (s *SyncJob) IsActive() bool <span class="cov8" title="1">{
        return s.Status == SyncStatusRunning
}</span>

func (s *SyncJob) IsCompleted() bool <span class="cov8" title="1">{
        return s.Status == SyncStatusCompleted || s.Status == SyncStatusFailed || s.Status == SyncStatusCancelled
}</span>

func (s *SyncJob) UpdateProgress(progress SyncProgress) <span class="cov8" title="1">{
        progress.LastUpdateTime = time.Now()
        s.Progress = progress
        s.UpdatedAt = time.Now()
}</span>

func (s *SyncJob) MarkStarted(rcloneJobID int64) <span class="cov8" title="1">{
        now := time.Now()
        s.Status = SyncStatusRunning
        s.StartedAt = &amp;now
        s.UpdatedAt = now
        s.RCloneJobID = &amp;rcloneJobID
}</span>

func (s *SyncJob) MarkCompleted(stats SyncStats) <span class="cov8" title="1">{
        now := time.Now()
        s.Status = SyncStatusCompleted
        s.CompletedAt = &amp;now
        s.UpdatedAt = now
        s.Progress.Percentage = 100.0
        s.Stats = stats
}</span>

func (s *SyncJob) MarkFailed(errorMsg string) <span class="cov8" title="1">{
        now := time.Now()
        s.Status = SyncStatusFailed
        s.ErrorMessage = errorMsg
        s.UpdatedAt = now
}</span>

func (s *SyncJob) MarkCancelled() <span class="cov8" title="1">{
        now := time.Now()
        s.Status = SyncStatusCancelled
        s.UpdatedAt = now
}</span>

// SyncFilter represents filtering options for sync job queries
type SyncFilter struct {
        Status    []SyncStatus `json:"status,omitempty"`
        Limit     int          `json:"limit,omitempty"`
        Offset    int          `json:"offset,omitempty"`
        SortBy    string       `json:"sort_by,omitempty"`
        SortOrder string       `json:"sort_order,omitempty"`
}

// SyncSummary represents aggregated sync job statistics
type SyncSummary struct {
        TotalSyncs     int `json:"total_syncs"`
        QueuedSyncs    int `json:"queued_syncs"`
        RunningSyncs   int `json:"running_syncs"`
        CompletedSyncs int `json:"completed_syncs"`
        FailedSyncs    int `json:"failed_syncs"`
        CancelledSyncs int `json:"cancelled_syncs"`
}</pre>
		
		<pre class="file" id="file10" style="display: none">package monitor

import (
        "context"
        "log/slog"
        "strconv"
        "sync"
        "time"

        "grabarr/internal/config"
        "grabarr/internal/interfaces"

        "golang.org/x/sys/unix"
)

type Monitor struct {
        config *config.Config

        // Resource monitoring state
        mu                sync.RWMutex
        lastResourceCheck time.Time
        resourceStatus    interfaces.ResourceStatus
        metrics           map[string]interface{}

        // Bandwidth monitoring
        bandwidthMonitor interfaces.BandwidthMonitor

        // Context management
        ctx    context.Context
        cancel context.CancelFunc
}

func New(cfg *config.Config) *Monitor <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        m := &amp;Monitor{
                config:  cfg,
                ctx:     ctx,
                cancel:  cancel,
                metrics: make(map[string]interface{}),
                bandwidthMonitor: &amp;mockBandwidthMonitor{}, // Use mock for now
        }

        // Initialize resource status
        m.updateResourceStatus()

        return m
}</span>

func (m *Monitor) Start() error <span class="cov0" title="0">{
        go m.monitorLoop()
        slog.Info("resource monitor started")
        return nil
}</span>

func (m *Monitor) Stop() error <span class="cov0" title="0">{
        m.cancel()
        slog.Info("resource monitor stopped")
        return nil
}</span>

func (m *Monitor) GetResourceStatus() interfaces.ResourceStatus <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.resourceStatus
}</span>

func (m *Monitor) GetMetrics() map[string]interface{} <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        // Create a copy to avoid race conditions
        metrics := make(map[string]interface{})
        for k, v := range m.metrics </span><span class="cov0" title="0">{
                metrics[k] = v
        }</span>

        <span class="cov0" title="0">return metrics</span>
}

func (m *Monitor) CanScheduleJob() bool <span class="cov0" title="0">{
        status := m.GetResourceStatus()
        return status.BandwidthAvailable &amp;&amp; status.DiskSpaceAvailable
}</span>

func (m *Monitor) monitorLoop() <span class="cov0" title="0">{
        resourceTicker := time.NewTicker(m.config.GetMonitoring().ResourceCheckInterval)
        defer resourceTicker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-m.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-resourceTicker.C:<span class="cov0" title="0">
                        m.updateResourceStatus()
                        m.updateMetrics()</span>
                }
        }
}

func (m *Monitor) updateResourceStatus() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.lastResourceCheck = time.Now()

        // Check bandwidth availability
        bandwidthUsage, err := m.bandwidthMonitor.GetCurrentUsage()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("failed to check bandwidth usage", "error", err)
                bandwidthUsage = 0
        }</span>

        <span class="cov0" title="0">cfg := m.config.GetResources()
        maxBandwidthUsage := float64(cfg.Bandwidth.MaxUsagePercent)

        m.resourceStatus.BandwidthUsage = bandwidthUsage
        m.resourceStatus.BandwidthAvailable = bandwidthUsage &lt; maxBandwidthUsage

        // Check disk space availability
        cacheFreeMB, arrayFreeMB := m.checkDiskSpace()
        m.resourceStatus.CacheDiskFree = cacheFreeMB * 1024 * 1024 // Convert to bytes
        m.resourceStatus.ArrayDiskFree = arrayFreeMB * 1024 * 1024

        // Parse minimum free space requirements
        cacheMinFreeMB := m.parseSizeString(cfg.Disk.CacheDriveMinFree)
        arrayMinFreeMB := m.parseSizeString(cfg.Disk.ArrayMinFree)

        m.resourceStatus.DiskSpaceAvailable = cacheFreeMB &gt;= cacheMinFreeMB &amp;&amp; arrayFreeMB &gt;= arrayMinFreeMB

        slog.Debug("resource status updated",
                "bandwidth_usage", bandwidthUsage,
                "bandwidth_available", m.resourceStatus.BandwidthAvailable,
                "cache_free_gb", cacheFreeMB/1024,
                "array_free_gb", arrayFreeMB/1024,
                "disk_space_available", m.resourceStatus.DiskSpaceAvailable,
        )</span>
}

func (m *Monitor) updateMetrics() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        now := time.Now()

        // System metrics
        m.metrics["timestamp"] = now.UTC()
        m.metrics["uptime"] = time.Since(now).String() // This will be updated by the main service

        // Resource metrics
        m.metrics["bandwidth"] = map[string]interface{}{
                "usage_percent": m.resourceStatus.BandwidthUsage,
                "available":     m.resourceStatus.BandwidthAvailable,
                "last_checked":  m.lastResourceCheck,
        }

        m.metrics["disk"] = map[string]interface{}{
                "cache_free_bytes":  m.resourceStatus.CacheDiskFree,
                "array_free_bytes":  m.resourceStatus.ArrayDiskFree,
                "space_available":   m.resourceStatus.DiskSpaceAvailable,
                "last_checked":      m.lastResourceCheck,
        }

        // Load average (Linux/Unix only)
        if loadAvg := m.getLoadAverage(); len(loadAvg) &gt; 0 </span><span class="cov0" title="0">{
                m.metrics["load_average"] = loadAvg
        }</span>

        // Memory usage
        <span class="cov0" title="0">if memInfo := m.getMemoryInfo(); memInfo != nil </span><span class="cov0" title="0">{
                m.metrics["memory"] = memInfo
        }</span>
}

func (m *Monitor) checkDiskSpace() (cacheFreeMB, arrayFreeMB int64) <span class="cov0" title="0">{
        cfg := m.config.GetResources()

        // Check cache drive space
        if stat, err := m.getDiskUsage(cfg.Disk.CacheDrivePath); err == nil </span><span class="cov0" title="0">{
                cacheFreeMB = int64(stat.Bavail * uint64(stat.Bsize)) / (1024 * 1024)
        }</span> else<span class="cov0" title="0"> {
                slog.Error("failed to check cache drive space", "path", cfg.Disk.CacheDrivePath, "error", err)
        }</span>

        // For array space, we'll check the parent directory of cache drive
        // In a real deployment, you might have a separate mount point for the array
        <span class="cov0" title="0">if stat, err := m.getDiskUsage("/"); err == nil </span><span class="cov0" title="0">{
                arrayFreeMB = int64(stat.Bavail * uint64(stat.Bsize)) / (1024 * 1024)
        }</span> else<span class="cov0" title="0"> {
                slog.Error("failed to check array space", "error", err)
        }</span>

        <span class="cov0" title="0">return cacheFreeMB, arrayFreeMB</span>
}

func (m *Monitor) getDiskUsage(path string) (*unix.Statfs_t, error) <span class="cov0" title="0">{
        var stat unix.Statfs_t
        err := unix.Statfs(path, &amp;stat)
        return &amp;stat, err
}</span>

func (m *Monitor) parseSizeString(sizeStr string) int64 <span class="cov0" title="0">{
        // Simple parser for size strings like "100GB", "1TB", etc.
        if len(sizeStr) &lt; 2 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">unit := sizeStr[len(sizeStr)-2:]
        valueStr := sizeStr[:len(sizeStr)-2]

        value, err := strconv.ParseFloat(valueStr, 64)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("failed to parse size string", "size", sizeStr, "error", err)
                return 0
        }</span>

        <span class="cov0" title="0">switch unit </span>{
        case "GB":<span class="cov0" title="0">
                return int64(value * 1024)</span> // Return in MB
        case "TB":<span class="cov0" title="0">
                return int64(value * 1024 * 1024)</span> // Return in MB
        case "MB":<span class="cov0" title="0">
                return int64(value)</span>
        default:<span class="cov0" title="0">
                slog.Warn("unknown size unit", "unit", unit, "size", sizeStr)
                return int64(value)</span> // Assume MB
        }
}

func (m *Monitor) getLoadAverage() []float64 <span class="cov0" title="0">{
        // This is a simplified implementation
        // In a real system, you might read from /proc/loadavg or use a system call
        return []float64{} // Placeholder
}</span>

func (m *Monitor) getMemoryInfo() map[string]interface{} <span class="cov0" title="0">{
        // This is a simplified implementation
        // In a real system, you might read from /proc/meminfo
        return map[string]interface{}{
                "total":     0,
                "available": 0,
                "used":      0,
                "cached":    0,
        }
}</span>

// Mock bandwidth monitor for testing
type mockBandwidthMonitor struct{}

func (m *mockBandwidthMonitor) GetCurrentUsage() (float64, error) <span class="cov0" title="0">{
        // Return a mock bandwidth usage between 0-50%
        // In a real implementation, this would:
        // 1. Connect to your seedbox via SSH or API
        // 2. Check current bandwidth usage (e.g., from vnstat, iftop, or router API)
        // 3. Calculate percentage based on your 1Gbps limit
        return 25.0, nil
}</span>

func (m *mockBandwidthMonitor) IsAvailable() bool <span class="cov0" title="0">{
        return true
}</span>

// Real bandwidth monitor implementation would look like this:
type sshBandwidthMonitor struct {
        host     string
        username string
        keyPath  string
}

func NewSSHBandwidthMonitor(host, username, keyPath string) interfaces.BandwidthMonitor <span class="cov0" title="0">{
        return &amp;sshBandwidthMonitor{
                host:     host,
                username: username,
                keyPath:  keyPath,
        }
}</span>

func (s *sshBandwidthMonitor) GetCurrentUsage() (float64, error) <span class="cov0" title="0">{
        // Implementation would:
        // 1. SSH to seedbox
        // 2. Run command like `vnstat -i eth0 --json` or check /proc/net/dev
        // 3. Calculate current bandwidth usage
        // 4. Return as percentage of total bandwidth

        // For now, return mock data
        return 30.0, nil
}</span>

func (s *sshBandwidthMonitor) IsAvailable() bool <span class="cov0" title="0">{
        // Check if we can connect to the seedbox
        return true
}</pre>
		
		<pre class="file" id="file11" style="display: none">package notifications

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "net/http"
        "strings"
        "time"

        "grabarr/internal/config"
        "grabarr/internal/models"
)

type PushoverNotifier struct {
        config     *config.Config
        httpClient *http.Client
        enabled    bool
}

type pushoverRequest struct {
        Token     string `json:"token"`
        User      string `json:"user"`
        Message   string `json:"message"`
        Title     string `json:"title,omitempty"`
        Priority  int    `json:"priority,omitempty"`
        URL       string `json:"url,omitempty"`
        URLTitle  string `json:"url_title,omitempty"`
        Device    string `json:"device,omitempty"`
        Timestamp int64  `json:"timestamp,omitempty"`
        Sound     string `json:"sound,omitempty"`
        Retry     int    `json:"retry,omitempty"`
        Expire    int    `json:"expire,omitempty"`
}

type pushoverResponse struct {
        Status  int      `json:"status"`
        Request string   `json:"request"`
        Errors  []string `json:"errors,omitempty"`
        Receipt string   `json:"receipt,omitempty"`
}

const pushoverAPIURL = "https://api.pushover.net/1/messages.json"

func NewPushoverNotifier(cfg *config.Config) *PushoverNotifier <span class="cov0" title="0">{
        return &amp;PushoverNotifier{
                config: cfg,
                httpClient: &amp;http.Client{
                        Timeout: 30 * time.Second,
                },
                enabled: cfg.GetNotifications().Pushover.Enabled,
        }
}</span>

func (p *PushoverNotifier) IsEnabled() bool <span class="cov0" title="0">{
        return p.enabled
}</span>

func (p *PushoverNotifier) NotifyJobFailed(job *models.Job) error <span class="cov0" title="0">{
        if !p.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">cfg := p.config.GetNotifications().Pushover

        title := fmt.Sprintf("Grabarr Job Failed: %s", job.Name)
        message := p.buildJobFailedMessage(job)

        req := pushoverRequest{
                Token:     cfg.Token,
                User:      cfg.User,
                Message:   message,
                Title:     title,
                Priority:  cfg.Priority,
                Timestamp: time.Now().Unix(),
                Sound:     "falling", // Default sound for failures
        }

        // Use higher priority for failed jobs that have exhausted retries
        if job.Retries &gt;= job.MaxRetries </span><span class="cov0" title="0">{
                req.Priority = 1 // High priority
                req.Sound = "siren"
        }</span>

        // If priority is 2 (emergency), set retry and expire
        <span class="cov0" title="0">if req.Priority == 2 </span><span class="cov0" title="0">{
                req.Retry = int(cfg.RetryInterval.Seconds())
                req.Expire = int(cfg.ExpireTime.Seconds())
        }</span>

        <span class="cov0" title="0">return p.sendNotification(req)</span>
}

func (p *PushoverNotifier) NotifyJobCompleted(job *models.Job) error <span class="cov0" title="0">{
        if !p.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Only notify for important jobs or if explicitly requested
        // You might want to add configuration for this
        <span class="cov0" title="0">if job.Priority &lt; 5 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">cfg := p.config.GetNotifications().Pushover

        title := fmt.Sprintf("Grabarr Job Completed: %s", job.Name)
        message := p.buildJobCompletedMessage(job)

        req := pushoverRequest{
                Token:     cfg.Token,
                User:      cfg.User,
                Message:   message,
                Title:     title,
                Priority:  -1, // Low priority for completions
                Timestamp: time.Now().Unix(),
                Sound:     "none", // Silent for completions
        }

        return p.sendNotification(req)</span>
}

func (p *PushoverNotifier) NotifySystemAlert(title, message string, priority int) error <span class="cov0" title="0">{
        if !p.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">cfg := p.config.GetNotifications().Pushover

        req := pushoverRequest{
                Token:     cfg.Token,
                User:      cfg.User,
                Message:   message,
                Title:     fmt.Sprintf("Grabarr Alert: %s", title),
                Priority:  priority,
                Timestamp: time.Now().Unix(),
                Sound:     "pushover", // Default sound
        }

        // Adjust sound based on priority
        switch priority </span>{
        case -2:<span class="cov0" title="0">
                req.Sound = "none"</span>
        case -1:<span class="cov0" title="0">
                req.Sound = "none"</span>
        case 0:<span class="cov0" title="0">
                req.Sound = "pushover"</span>
        case 1:<span class="cov0" title="0">
                req.Sound = "persistent"</span>
        case 2:<span class="cov0" title="0">
                req.Sound = "siren"
                req.Retry = int(cfg.RetryInterval.Seconds())
                req.Expire = int(cfg.ExpireTime.Seconds())</span>
        }

        <span class="cov0" title="0">return p.sendNotification(req)</span>
}

func (p *PushoverNotifier) sendNotification(req pushoverRequest) error <span class="cov0" title="0">{
        jsonData, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal pushover request: %w", err)
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        httpReq, err := http.NewRequestWithContext(ctx, "POST", pushoverAPIURL, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create HTTP request: %w", err)
        }</span>

        <span class="cov0" title="0">httpReq.Header.Set("Content-Type", "application/json")
        httpReq.Header.Set("User-Agent", "grabarr/1.0")

        slog.Debug("sending pushover notification",
                "title", req.Title,
                "priority", req.Priority)

        resp, err := p.httpClient.Do(httpReq)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send pushover notification: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var pushoverResp pushoverResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;pushoverResp); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode pushover response: %w", err)
        }</span>

        <span class="cov0" title="0">if pushoverResp.Status != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("pushover API error: %s", strings.Join(pushoverResp.Errors, ", "))
        }</span>

        <span class="cov0" title="0">slog.Info("pushover notification sent successfully",
                "request_id", pushoverResp.Request,
                "receipt", pushoverResp.Receipt)

        return nil</span>
}

func (p *PushoverNotifier) buildJobFailedMessage(job *models.Job) string <span class="cov0" title="0">{
        var msg strings.Builder

        msg.WriteString(fmt.Sprintf("Job: %s\n", job.Name))
        msg.WriteString(fmt.Sprintf("Remote Path: %s\n", job.RemotePath))
        msg.WriteString(fmt.Sprintf("Status: %s\n", job.Status))
        msg.WriteString(fmt.Sprintf("Retry: %d/%d\n", job.Retries, job.MaxRetries))

        if job.ErrorMessage != "" </span><span class="cov0" title="0">{
                msg.WriteString(fmt.Sprintf("Error: %s\n", job.ErrorMessage))
        }</span>

        <span class="cov0" title="0">if job.StartedAt != nil </span><span class="cov0" title="0">{
                duration := time.Since(*job.StartedAt)
                msg.WriteString(fmt.Sprintf("Duration: %s\n", duration.Round(time.Second)))
        }</span>

        <span class="cov0" title="0">if job.Progress.TransferredBytes &gt; 0 &amp;&amp; job.Progress.TotalBytes &gt; 0 </span><span class="cov0" title="0">{
                msg.WriteString(fmt.Sprintf("Progress: %.1f%% (%s/%s)\n",
                        job.Progress.Percentage,
                        formatBytes(job.Progress.TransferredBytes),
                        formatBytes(job.Progress.TotalBytes)))
        }</span>

        <span class="cov0" title="0">if job.Metadata.Category != "" </span><span class="cov0" title="0">{
                msg.WriteString(fmt.Sprintf("Category: %s\n", job.Metadata.Category))
        }</span>

        <span class="cov0" title="0">msg.WriteString(fmt.Sprintf("Job ID: %d", job.ID))

        return msg.String()</span>
}

func (p *PushoverNotifier) buildJobCompletedMessage(job *models.Job) string <span class="cov0" title="0">{
        var msg strings.Builder

        msg.WriteString(fmt.Sprintf("Job: %s\n", job.Name))
        msg.WriteString(fmt.Sprintf("Remote Path: %s\n", job.RemotePath))

        if job.StartedAt != nil &amp;&amp; job.CompletedAt != nil </span><span class="cov0" title="0">{
                duration := job.CompletedAt.Sub(*job.StartedAt)
                msg.WriteString(fmt.Sprintf("Duration: %s\n", duration.Round(time.Second)))
        }</span>

        <span class="cov0" title="0">if job.Progress.TotalBytes &gt; 0 </span><span class="cov0" title="0">{
                msg.WriteString(fmt.Sprintf("Size: %s\n", formatBytes(job.Progress.TotalBytes)))
        }</span>

        <span class="cov0" title="0">if job.Progress.TransferSpeed &gt; 0 </span><span class="cov0" title="0">{
                msg.WriteString(fmt.Sprintf("Avg Speed: %s/s\n", formatBytes(job.Progress.TransferSpeed)))
        }</span>

        <span class="cov0" title="0">if job.Metadata.Category != "" </span><span class="cov0" title="0">{
                msg.WriteString(fmt.Sprintf("Category: %s\n", job.Metadata.Category))
        }</span>

        <span class="cov0" title="0">msg.WriteString(fmt.Sprintf("Job ID: %d", job.ID))

        return msg.String()</span>
}

func formatBytes(bytes int64) string <span class="cov0" title="0">{
        if bytes == 0 </span><span class="cov0" title="0">{
                return "0 B"
        }</span>

        <span class="cov0" title="0">const unit = 1024
        if bytes &lt; unit </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d B", bytes)
        }</span>

        <span class="cov0" title="0">div, exp := int64(unit), 0
        for n := bytes / unit; n &gt;= unit; n /= unit </span><span class="cov0" title="0">{
                div *= unit
                exp++
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])</span>
}

// TestNotification sends a test notification to verify configuration
func (p *PushoverNotifier) TestNotification() error <span class="cov0" title="0">{
        if !p.enabled </span><span class="cov0" title="0">{
                return fmt.Errorf("pushover notifications are disabled")
        }</span>

        <span class="cov0" title="0">cfg := p.config.GetNotifications().Pushover

        req := pushoverRequest{
                Token:     cfg.Token,
                User:      cfg.User,
                Message:   "This is a test notification from Grabarr. If you received this, your Pushover configuration is working correctly!",
                Title:     "Grabarr Test Notification",
                Priority:  0,
                Timestamp: time.Now().Unix(),
                Sound:     "pushover",
        }

        return p.sendNotification(req)</span>
}</pre>
		
		<pre class="file" id="file12" style="display: none">package queue

import (
        "context"
        "fmt"
        "log/slog"
        "math"
        "sync"
        "time"

        "grabarr/internal/config"
        "grabarr/internal/interfaces"
        "grabarr/internal/models"
        "grabarr/internal/repository"
)

type queue struct {
        repo     *repository.Repository
        config   *config.Config
        executor interfaces.JobExecutor

        // Internal state
        mu              sync.RWMutex
        running         bool
        activeJobs      map[int64]context.CancelFunc
        jobQueue        chan *models.Job
        schedulerCtx    context.Context
        schedulerCancel context.CancelFunc

        // Resource management
        resourceChecker interfaces.ResourceChecker

        // Cleanup
        lastCleanup time.Time
}

func New(repo *repository.Repository, config *config.Config, resourceChecker interfaces.ResourceChecker) interfaces.JobQueue <span class="cov8" title="1">{
        return &amp;queue{
                repo:            repo,
                config:          config,
                activeJobs:      make(map[int64]context.CancelFunc),
                jobQueue:        make(chan *models.Job, 1000), // Buffered channel for job queue
                resourceChecker: resourceChecker,
                lastCleanup:     time.Now(),
        }
}</span>

func (q *queue) SetJobExecutor(executor interfaces.JobExecutor) <span class="cov8" title="1">{
        q.mu.Lock()
        defer q.mu.Unlock()
        q.executor = executor
}</span>

func (q *queue) Start(ctx context.Context) error <span class="cov8" title="1">{
        q.mu.Lock()
        defer q.mu.Unlock()

        if q.running </span><span class="cov8" title="1">{
                return fmt.Errorf("queue already running")
        }</span>

        <span class="cov8" title="1">if q.executor == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("job executor not set")
        }</span>

        <span class="cov8" title="1">q.running = true
        q.schedulerCtx, q.schedulerCancel = context.WithCancel(ctx)

        // Load existing queued/pending jobs from database
        if err := q.loadExistingJobs(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load existing jobs: %w", err)
        }</span>

        // Start the scheduler goroutine
        <span class="cov8" title="1">go q.scheduler()

        // Start cleanup goroutine
        go q.cleanupRoutine()

        slog.Info("job queue started")
        return nil</span>
}

func (q *queue) Stop() error <span class="cov8" title="1">{
        q.mu.Lock()
        defer q.mu.Unlock()

        if !q.running </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">q.running = false

        // Cancel scheduler
        if q.schedulerCancel != nil </span><span class="cov8" title="1">{
                q.schedulerCancel()
        }</span>

        // Cancel all active jobs
        <span class="cov8" title="1">for jobID, cancel := range q.activeJobs </span><span class="cov0" title="0">{
                slog.Info("cancelling active job", "job_id", jobID)
                cancel()
        }</span>

        // Wait for jobs to finish or timeout
        <span class="cov8" title="1">timeout := time.After(q.config.GetServer().ShutdownTimeout)
        ticker := time.NewTicker(100 * time.Millisecond)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-timeout:<span class="cov8" title="1">
                        slog.Warn("timeout waiting for jobs to finish", "active_jobs", len(q.activeJobs))
                        return nil</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        if len(q.activeJobs) == 0 </span><span class="cov8" title="1">{
                                slog.Info("all jobs finished, queue stopped")
                                return nil
                        }</span>
                }
        }
}

func (q *queue) Enqueue(job *models.Job) error <span class="cov8" title="1">{
        // Set defaults
        if job.Status == "" </span><span class="cov8" title="1">{
                job.Status = models.JobStatusQueued
        }</span>
        <span class="cov8" title="1">if job.MaxRetries == 0 </span><span class="cov8" title="1">{
                job.MaxRetries = q.config.GetJobs().MaxRetries
        }</span>

        // Create job in database
        <span class="cov8" title="1">if err := q.repo.CreateJob(job); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create job in database: %w", err)
        }</span>

        // Add to in-memory queue
        <span class="cov8" title="1">select </span>{
        case q.jobQueue &lt;- job:<span class="cov8" title="1">
                slog.Info("job enqueued", "job_id", job.ID, "name", job.Name)
                return nil</span>
        default:<span class="cov0" title="0">
                // Queue is full, job is still in database but not in memory queue
                slog.Warn("job queue full, job saved to database", "job_id", job.ID)
                return nil</span>
        }
}

func (q *queue) GetJob(id int64) (*models.Job, error) <span class="cov8" title="1">{
        return q.repo.GetJob(id)
}</span>

func (q *queue) GetJobs(filter models.JobFilter) ([]*models.Job, error) <span class="cov8" title="1">{
        return q.repo.GetJobs(filter)
}</span>

func (q *queue) CancelJob(id int64) error <span class="cov8" title="1">{
        q.mu.Lock()
        defer q.mu.Unlock()

        // Cancel if currently running
        if cancel, exists := q.activeJobs[id]; exists </span><span class="cov0" title="0">{
                cancel()
                delete(q.activeJobs, id)
        }</span>

        // Update job status in database
        <span class="cov8" title="1">job, err := q.repo.GetJob(id)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to get job: %w", err)
        }</span>

        <span class="cov8" title="1">if !job.IsCompleted() </span><span class="cov8" title="1">{
                job.MarkCancelled()
                if err := q.repo.UpdateJob(job); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update job status: %w", err)
                }</span>
        }

        <span class="cov8" title="1">slog.Info("job cancelled", "job_id", id)
        return nil</span>
}

func (q *queue) GetSummary() (*models.JobSummary, error) <span class="cov8" title="1">{
        return q.repo.GetJobSummary()
}</span>

func (q *queue) loadExistingJobs() error <span class="cov8" title="1">{
        // Load jobs that need to be recovered: queued, pending, and running
        jobs, err := q.repo.GetJobs(models.JobFilter{
                Status: []models.JobStatus{models.JobStatusQueued, models.JobStatusPending, models.JobStatusRunning},
                SortBy: "priority",
                SortOrder: "DESC",
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, job := range jobs </span><span class="cov0" title="0">{
                // Reset pending and running jobs to queued for recovery
                if job.Status == models.JobStatusPending || job.Status == models.JobStatusRunning </span><span class="cov0" title="0">{
                        oldStatus := job.Status
                        job.Status = models.JobStatusQueued
                        if err := q.repo.UpdateJob(job); err != nil </span><span class="cov0" title="0">{
                                slog.Error("failed to reset job to queued", "job_id", job.ID, "old_status", oldStatus, "error", err)
                                continue</span>
                        }
                        <span class="cov0" title="0">slog.Info("recovered interrupted job", "job_id", job.ID, "name", job.Name, "previous_status", oldStatus)</span>
                }

                <span class="cov0" title="0">select </span>{
                case q.jobQueue &lt;- job:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0">
                        slog.Warn("job queue full during startup, some jobs may be delayed", "job_id", job.ID)</span>
                }
        }

        <span class="cov8" title="1">slog.Info("loaded existing jobs", "count", len(jobs))
        return nil</span>
}

func (q *queue) scheduler() <span class="cov8" title="1">{
        ticker := time.NewTicker(5 * time.Second) // Check every 5 seconds
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-q.schedulerCtx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        q.processQueue()</span>
                case job := &lt;-q.jobQueue:<span class="cov0" title="0">
                        // Process job immediately if resources allow
                        if q.canScheduleNewJob() &amp;&amp; q.resourceChecker.CanScheduleJob() </span><span class="cov0" title="0">{
                                q.scheduleJob(job)
                        }</span> else<span class="cov0" title="0"> {
                                // Put job back in queue for later
                                job.Status = models.JobStatusPending
                                if err := q.repo.UpdateJob(job); err != nil </span><span class="cov0" title="0">{
                                        slog.Error("failed to update job status to pending", "job_id", job.ID, "error", err)
                                }</span>

                                <span class="cov0" title="0">select </span>{
                                case q.jobQueue &lt;- job:<span class="cov0" title="0"></span>
                                default:<span class="cov0" title="0">
                                        slog.Error("failed to re-queue job", "job_id", job.ID)</span>
                                }
                        }
                }
        }
}

func (q *queue) processQueue() <span class="cov0" title="0">{
        if !q.canScheduleNewJob() || !q.resourceChecker.CanScheduleJob() </span><span class="cov0" title="0">{
                return
        }</span>

        // Try to process jobs from the queue
        <span class="cov0" title="0">for q.canScheduleNewJob() &amp;&amp; q.resourceChecker.CanScheduleJob() </span><span class="cov0" title="0">{
                select </span>{
                case job := &lt;-q.jobQueue:<span class="cov0" title="0">
                        q.scheduleJob(job)</span>
                default:<span class="cov0" title="0">
                        // No jobs in queue, try to load from database
                        jobs, err := q.repo.GetJobs(models.JobFilter{
                                Status: []models.JobStatus{models.JobStatusQueued, models.JobStatusPending},
                                SortBy: "priority",
                                SortOrder: "DESC",
                                Limit: 10,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Error("failed to load jobs from database", "error", err)
                                return
                        }</span>

                        <span class="cov0" title="0">if len(jobs) == 0 </span><span class="cov0" title="0">{
                                return // No more jobs to process
                        }</span>

                        // Add jobs to queue
                        <span class="cov0" title="0">for _, job := range jobs </span><span class="cov0" title="0">{
                                if q.canScheduleNewJob() &amp;&amp; q.resourceChecker.CanScheduleJob() </span><span class="cov0" title="0">{
                                        q.scheduleJob(job)
                                }</span> else<span class="cov0" title="0"> {
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">return</span>
                }
        }
}

func (q *queue) canScheduleNewJob() bool <span class="cov8" title="1">{
        q.mu.RLock()
        defer q.mu.RUnlock()

        maxConcurrent := q.config.GetJobs().MaxConcurrent
        return len(q.activeJobs) &lt; maxConcurrent
}</span>

func (q *queue) scheduleJob(job *models.Job) <span class="cov0" title="0">{
        q.mu.Lock()
        defer q.mu.Unlock()

        // Create context for this job
        ctx, cancel := context.WithCancel(q.schedulerCtx)
        q.activeJobs[job.ID] = cancel

        // Start job execution in goroutine
        go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        q.mu.Lock()
                        delete(q.activeJobs, job.ID)
                        q.mu.Unlock()
                }</span>()

                <span class="cov0" title="0">q.executeJob(ctx, job)</span>
        }()

        <span class="cov0" title="0">slog.Info("job scheduled", "job_id", job.ID, "name", job.Name)</span>
}

func (q *queue) executeJob(ctx context.Context, job *models.Job) <span class="cov8" title="1">{
        // Mark job as started
        job.MarkStarted()
        if err := q.repo.UpdateJob(job); err != nil </span><span class="cov0" title="0">{
                slog.Error("failed to mark job as started", "job_id", job.ID, "error", err)
                return
        }</span>

        // Create job attempt record
        <span class="cov8" title="1">attempt := &amp;models.JobAttempt{
                JobID:      job.ID,
                AttemptNum: job.Retries + 1,
                Status:     models.JobStatusRunning,
        }
        if err := q.repo.CreateJobAttempt(attempt); err != nil </span><span class="cov0" title="0">{
                slog.Error("failed to create job attempt", "job_id", job.ID, "error", err)
                // Continue execution despite logging error
        }</span>

        // Execute the job
        <span class="cov8" title="1">err := q.executor.Execute(ctx, job)

        // Update attempt record
        now := time.Now()
        attempt.EndedAt = &amp;now

        if err != nil </span><span class="cov8" title="1">{
                slog.Error("job execution failed", "job_id", job.ID, "attempt", attempt.AttemptNum, "error", err)

                attempt.Status = models.JobStatusFailed
                attempt.ErrorMessage = err.Error()

                // Handle retry logic
                if job.CanRetry() </span><span class="cov0" title="0">{
                        backoff := q.calculateRetryBackoff(job.Retries)
                        slog.Info("job will be retried", "job_id", job.ID, "retry_in", backoff)

                        job.IncrementRetry()
                        if err := q.repo.UpdateJob(job); err != nil </span><span class="cov0" title="0">{
                                slog.Error("failed to update job for retry", "job_id", job.ID, "error", err)
                        }</span>

                        // Schedule retry
                        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                                time.Sleep(backoff)
                                select </span>{
                                case q.jobQueue &lt;- job:<span class="cov0" title="0"></span>
                                case &lt;-q.schedulerCtx.Done():<span class="cov0" title="0"></span>
                                }
                        }()
                } else<span class="cov8" title="1"> {
                        job.MarkFailed(err.Error())
                        if err := q.repo.UpdateJob(job); err != nil </span><span class="cov0" title="0">{
                                slog.Error("failed to mark job as failed", "job_id", job.ID, "error", err)
                        }</span>

                        // TODO: Send notification about failed job
                }
        } else<span class="cov8" title="1"> {
                slog.Info("job completed successfully", "job_id", job.ID)

                attempt.Status = models.JobStatusCompleted
                job.MarkCompleted()

                if err := q.repo.UpdateJob(job); err != nil </span><span class="cov0" title="0">{
                        slog.Error("failed to mark job as completed", "job_id", job.ID, "error", err)
                }</span>
        }

        // Update attempt record
        <span class="cov8" title="1">if err := q.repo.UpdateJobAttempt(attempt); err != nil </span><span class="cov0" title="0">{
                slog.Error("failed to update job attempt", "job_id", job.ID, "error", err)
        }</span>
}

func (q *queue) calculateRetryBackoff(retryCount int) time.Duration <span class="cov8" title="1">{
        cfg := q.config.GetJobs()

        // Exponential backoff: base * (2 ^ retryCount)
        backoff := cfg.RetryBackoffBase * time.Duration(math.Pow(2, float64(retryCount)))

        // Cap at maximum backoff
        if backoff &gt; cfg.RetryBackoffMax </span><span class="cov8" title="1">{
                backoff = cfg.RetryBackoffMax
        }</span>

        <span class="cov8" title="1">return backoff</span>
}

func (q *queue) cleanupRoutine() <span class="cov8" title="1">{
        ticker := time.NewTicker(1 * time.Hour) // Run cleanup every hour
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-q.schedulerCtx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        q.performCleanup()</span>
                }
        }
}

func (q *queue) performCleanup() <span class="cov0" title="0">{
        cfg := q.config.GetJobs()
        now := time.Now()

        completedBefore := now.Add(-cfg.CleanupCompletedAfter)
        failedBefore := now.Add(-cfg.CleanupFailedAfter)

        count, err := q.repo.CleanupOldJobs(completedBefore, failedBefore)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("failed to cleanup old jobs", "error", err)
                return
        }</span>

        <span class="cov0" title="0">if count &gt; 0 </span><span class="cov0" title="0">{
                slog.Info("cleaned up old jobs", "count", count)
        }</span>

        // Update last cleanup time
        <span class="cov0" title="0">if err := q.repo.SetConfig("last_cleanup", now.Format(time.RFC3339)); err != nil </span><span class="cov0" title="0">{
                slog.Error("failed to update last cleanup time", "error", err)
        }</span>
}</pre>
		
		<pre class="file" id="file13" style="display: none">package rclone

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "grabarr/internal/models"
        "io"
        "net/http"
        "time"
)

// Client represents an HTTP client for the rclone daemon
type Client struct {
        baseURL    string
        httpClient *http.Client
}

// NewClient creates a new rclone HTTP client
func NewClient(baseURL string) *Client <span class="cov8" title="1">{
        return &amp;Client{
                baseURL: baseURL,
                httpClient: &amp;http.Client{
                        Timeout: 30 * time.Second, // Short timeout since we use async operations
                },
        }
}</span>

// SyncCopyRequest represents a request to copy files/directories using sync/copy
type SyncCopyRequest struct {
        SrcFs   string                 `json:"srcFs"`
        DstFs   string                 `json:"dstFs"`
        Filter  map[string]interface{} `json:"_filter,omitempty"`
        Async   bool                   `json:"_async,omitempty"`
        Config  map[string]interface{} `json:"_config,omitempty"`
}


// CopyResponse represents the response from a copy operation
type CopyResponse struct {
        JobID int64 `json:"jobid"`
}

// JobStatus represents the status of a running job
type JobStatus struct {
        ID        int64     `json:"id"`
        Name      string    `json:"name"`
        Group     string    `json:"group"`
        StartTime time.Time `json:"startTime"`
        EndTime   time.Time `json:"endTime"`
        Error     string    `json:"error"`
        Finished  bool      `json:"finished"`
        Success   bool      `json:"success"`
        Duration  float64   `json:"duration"`
        Progress  string    `json:"progress"`
        Output    Output    `json:"output"`
}

// Output represents the transfer statistics from rclone
type Output struct {
        Bytes             int64   `json:"bytes"`
        Checks            int64   `json:"checks"`
        Deletes           int64   `json:"deletes"`
        ElapsedTime       float64 `json:"elapsedTime"`
        Errors            int64   `json:"errors"`
        ETA               *int64  `json:"eta"`
        FatalError        bool    `json:"fatalError"`
        Renames           int64   `json:"renames"`
        RetryError        bool    `json:"retryError"`
        ServerSideCopies  int64   `json:"serverSideCopies"`
        ServerSideCopyBytes int64 `json:"serverSideCopyBytes"`
        ServerSideMoveBytes int64 `json:"serverSideMoveBytes"`
        ServerSideMoves   int64   `json:"serverSideMoves"`
        Speed             float64 `json:"speed"`
        TotalBytes        int64   `json:"totalBytes"`
        TotalChecks       int64   `json:"totalChecks"`
        TotalTransfers    int64   `json:"totalTransfers"`
        TransferTime      float64 `json:"transferTime"`
        Transfers         int64   `json:"transfers"`
}

// JobListResponse represents the response from job/list
type JobListResponse struct {
        JobIDs []int64 `json:"jobids"`
}


// Copy initiates a copy operation for files or directories with optional filtering
func (c *Client) Copy(ctx context.Context, srcFs, dstFs string, filter map[string]interface{}) (*models.RCloneCopyResponse, error) <span class="cov8" title="1">{
        req := SyncCopyRequest{
                SrcFs:  srcFs,
                DstFs:  dstFs,
                Filter: filter,
                Async:  true, // Always use async to avoid timeouts on large transfers
        }

        var resp CopyResponse
        err := c.makeRequest(ctx, "POST", "/sync/copy", req, &amp;resp)
        return &amp;models.RCloneCopyResponse{JobID: resp.JobID}, err
}</span>

// CopyWithIgnoreExisting initiates a copy operation that skips existing files
func (c *Client) CopyWithIgnoreExisting(ctx context.Context, srcFs, dstFs string, filter map[string]interface{}) (*models.RCloneCopyResponse, error) <span class="cov8" title="1">{
        req := SyncCopyRequest{
                SrcFs:  srcFs,
                DstFs:  dstFs,
                Filter: filter,
                Async:  true, // Always use async to avoid timeouts on large transfers
                Config: map[string]interface{}{
                        "IgnoreExisting": true, // Skip files that already exist on destination
                },
        }

        var resp CopyResponse
        err := c.makeRequest(ctx, "POST", "/sync/copy", req, &amp;resp)
        return &amp;models.RCloneCopyResponse{JobID: resp.JobID}, err
}</span>


// GetJobStatus gets the status of a specific job
func (c *Client) GetJobStatus(ctx context.Context, jobID int64) (*models.RCloneJobStatus, error) <span class="cov8" title="1">{
        var status JobStatus
        endpoint := fmt.Sprintf("/job/status?jobid=%d", jobID)
        err := c.makeRequest(ctx, "POST", endpoint, nil, &amp;status)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert to model type
        <span class="cov8" title="1">return &amp;models.RCloneJobStatus{
                ID:       status.ID,
                Name:     status.Name,
                Group:    status.Group,
                Error:    status.Error,
                Finished: status.Finished,
                Success:  status.Success,
                Duration: status.Duration,
                Progress: status.Progress,
                Output: models.RCloneOutput{
                        Bytes:          status.Output.Bytes,
                        Speed:          status.Output.Speed,
                        TotalBytes:     status.Output.TotalBytes,
                        TotalTransfers: status.Output.TotalTransfers,
                        Transfers:      status.Output.Transfers,
                        Errors:         status.Output.Errors,
                },
        }, nil</span>
}

// ListJobs lists all active jobs
func (c *Client) ListJobs(ctx context.Context) (*models.RCloneJobListResponse, error) <span class="cov8" title="1">{
        var resp JobListResponse
        err := c.makeRequest(ctx, "POST", "/job/list", nil, &amp;resp)
        return &amp;models.RCloneJobListResponse{JobIDs: resp.JobIDs}, err
}</span>

// StopJob stops a running job
func (c *Client) StopJob(ctx context.Context, jobID int64) error <span class="cov8" title="1">{
        endpoint := fmt.Sprintf("/job/stop?jobid=%d", jobID)
        return c.makeRequest(ctx, "POST", endpoint, nil, nil)
}</span>


// Ping checks if the rclone daemon is responsive
func (c *Client) Ping(ctx context.Context) error <span class="cov8" title="1">{
        return c.makeRequest(ctx, "POST", "/core/pid", nil, nil)
}</span>

// makeRequest makes an HTTP request to the rclone daemon
func (c *Client) makeRequest(ctx context.Context, method, endpoint string, request interface{}, response interface{}) error <span class="cov8" title="1">{
        var body io.Reader
        if request != nil </span><span class="cov8" title="1">{
                jsonData, err := json.Marshal(request)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal request: %w", err)
                }</span>
                <span class="cov8" title="1">body = bytes.NewBuffer(jsonData)</span>
        }

        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, method, c.baseURL+endpoint, body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov8" title="1">if request != nil </span><span class="cov8" title="1">{
                req.Header.Set("Content-Type", "application/json")
        }</span>

        <span class="cov8" title="1">resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("request failed: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov8" title="1">{
                bodyBytes, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("HTTP %d: %s", resp.StatusCode, string(bodyBytes))
        }</span>

        <span class="cov8" title="1">if response != nil </span><span class="cov8" title="1">{
                if err := json.NewDecoder(resp.Body).Decode(response); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to decode response: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file14" style="display: none">package repository

import (
        "database/sql"
        "embed"
        "fmt"
        "log/slog"
        "strings"
        "time"

        "grabarr/internal/models"

        _ "github.com/mattn/go-sqlite3"
)

//go:embed schema.sql
var schemaFS embed.FS

type Repository struct {
        db *sql.DB
}

func New(dbPath string) (*Repository, error) <span class="cov8" title="1">{
        db, err := sql.Open("sqlite3", fmt.Sprintf("%s?_journal_mode=WAL&amp;_timeout=5000&amp;_cache_size=2000", dbPath))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        <span class="cov8" title="1">db.SetMaxOpenConns(10)
        db.SetMaxIdleConns(5)
        db.SetConnMaxLifetime(time.Hour)

        repo := &amp;Repository{db: db}

        if err := repo.initSchema(); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, fmt.Errorf("failed to initialize schema: %w", err)
        }</span>

        <span class="cov8" title="1">return repo, nil</span>
}

func (r *Repository) Close() error <span class="cov8" title="1">{
        return r.db.Close()
}</span>

func (r *Repository) initSchema() error <span class="cov8" title="1">{
        schemaSQL, err := schemaFS.ReadFile("schema.sql")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read schema file: %w", err)
        }</span>

        <span class="cov8" title="1">_, err = r.db.Exec(string(schemaSQL))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute schema: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Job operations
func (r *Repository) CreateJob(job *models.Job) error <span class="cov8" title="1">{
        query := `
                INSERT INTO jobs (
                        name, remote_path, local_path, status, priority, max_retries,
                        progress, metadata, estimated_size
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `

        result, err := r.db.Exec(query,
                job.Name, job.RemotePath, job.LocalPath, job.Status, job.Priority,
                job.MaxRetries, job.Progress, job.Metadata, job.EstimatedSize)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create job: %w", err)
        }</span>

        <span class="cov8" title="1">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get job ID: %w", err)
        }</span>

        <span class="cov8" title="1">job.ID = id
        job.CreatedAt = time.Now()
        job.UpdatedAt = time.Now()

        return nil</span>
}

func (r *Repository) GetJob(id int64) (*models.Job, error) <span class="cov8" title="1">{
        query := `
                SELECT id, name, remote_path, local_path, status, priority, retries, max_retries,
                           error_message, progress, metadata, created_at, updated_at, started_at,
                           completed_at, estimated_size, transferred_bytes, transfer_speed
                FROM jobs WHERE id = ?
        `

        var job models.Job
        var errorMessage sql.NullString
        var startedAt, completedAt sql.NullTime

        err := r.db.QueryRow(query, id).Scan(
                &amp;job.ID, &amp;job.Name, &amp;job.RemotePath, &amp;job.LocalPath, &amp;job.Status,
                &amp;job.Priority, &amp;job.Retries, &amp;job.MaxRetries, &amp;errorMessage,
                &amp;job.Progress, &amp;job.Metadata, &amp;job.CreatedAt, &amp;job.UpdatedAt,
                &amp;startedAt, &amp;completedAt, &amp;job.EstimatedSize, &amp;job.TransferredBytes,
                &amp;job.TransferSpeed)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("job %d not found", id)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get job: %w", err)</span>
        }

        <span class="cov8" title="1">if errorMessage.Valid </span><span class="cov8" title="1">{
                job.ErrorMessage = errorMessage.String
        }</span>
        <span class="cov8" title="1">if startedAt.Valid </span><span class="cov8" title="1">{
                job.StartedAt = &amp;startedAt.Time
        }</span>
        <span class="cov8" title="1">if completedAt.Valid </span><span class="cov0" title="0">{
                job.CompletedAt = &amp;completedAt.Time
        }</span>

        <span class="cov8" title="1">return &amp;job, nil</span>
}

func (r *Repository) GetJobs(filter models.JobFilter) ([]*models.Job, error) <span class="cov8" title="1">{
        query := `
                SELECT id, name, remote_path, local_path, status, priority, retries, max_retries,
                           error_message, progress, metadata, created_at, updated_at, started_at,
                           completed_at, estimated_size, transferred_bytes, transfer_speed
                FROM jobs
        `

        var conditions []string
        var args []interface{}

        if len(filter.Status) &gt; 0 </span><span class="cov8" title="1">{
                placeholders := strings.Repeat("?,", len(filter.Status))
                placeholders = placeholders[:len(placeholders)-1] // Remove trailing comma
                conditions = append(conditions, fmt.Sprintf("status IN (%s)", placeholders))
                for _, status := range filter.Status </span><span class="cov8" title="1">{
                        args = append(args, status)
                }</span>
        }

        <span class="cov8" title="1">if filter.Category != "" </span><span class="cov8" title="1">{
                conditions = append(conditions, "JSON_EXTRACT(metadata, '$.category') = ?")
                args = append(args, filter.Category)
        }</span>

        <span class="cov8" title="1">if filter.MinPriority != nil </span><span class="cov8" title="1">{
                conditions = append(conditions, "priority &gt;= ?")
                args = append(args, *filter.MinPriority)
        }</span>

        <span class="cov8" title="1">if filter.MaxPriority != nil </span><span class="cov0" title="0">{
                conditions = append(conditions, "priority &lt;= ?")
                args = append(args, *filter.MaxPriority)
        }</span>

        <span class="cov8" title="1">if len(conditions) &gt; 0 </span><span class="cov8" title="1">{
                query += " WHERE " + strings.Join(conditions, " AND ")
        }</span>

        // Sorting
        <span class="cov8" title="1">sortBy := "created_at"
        if filter.SortBy != "" </span><span class="cov8" title="1">{
                sortBy = filter.SortBy
        }</span>
        <span class="cov8" title="1">sortOrder := "DESC"
        if filter.SortOrder != "" </span><span class="cov8" title="1">{
                sortOrder = filter.SortOrder
        }</span>
        <span class="cov8" title="1">query += fmt.Sprintf(" ORDER BY %s %s", sortBy, sortOrder)

        // Pagination
        if filter.Limit &gt; 0 </span><span class="cov8" title="1">{
                query += " LIMIT ?"
                args = append(args, filter.Limit)
        }</span>
        <span class="cov8" title="1">if filter.Offset &gt; 0 </span><span class="cov8" title="1">{
                query += " OFFSET ?"
                args = append(args, filter.Offset)
        }</span>

        <span class="cov8" title="1">rows, err := r.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query jobs: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var jobs []*models.Job
        for rows.Next() </span><span class="cov8" title="1">{
                var job models.Job
                var errorMessage sql.NullString
                var startedAt, completedAt sql.NullTime

                err := rows.Scan(
                        &amp;job.ID, &amp;job.Name, &amp;job.RemotePath, &amp;job.LocalPath, &amp;job.Status,
                        &amp;job.Priority, &amp;job.Retries, &amp;job.MaxRetries, &amp;errorMessage,
                        &amp;job.Progress, &amp;job.Metadata, &amp;job.CreatedAt, &amp;job.UpdatedAt,
                        &amp;startedAt, &amp;completedAt, &amp;job.EstimatedSize, &amp;job.TransferredBytes,
                        &amp;job.TransferSpeed)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan job: %w", err)
                }</span>

                <span class="cov8" title="1">if errorMessage.Valid </span><span class="cov0" title="0">{
                        job.ErrorMessage = errorMessage.String
                }</span>
                <span class="cov8" title="1">if startedAt.Valid </span><span class="cov0" title="0">{
                        job.StartedAt = &amp;startedAt.Time
                }</span>
                <span class="cov8" title="1">if completedAt.Valid </span><span class="cov8" title="1">{
                        job.CompletedAt = &amp;completedAt.Time
                }</span>

                <span class="cov8" title="1">jobs = append(jobs, &amp;job)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating jobs: %w", err)
        }</span>

        <span class="cov8" title="1">return jobs, nil</span>
}

func (r *Repository) UpdateJob(job *models.Job) error <span class="cov8" title="1">{
        query := `
                UPDATE jobs SET
                        status = ?, priority = ?, retries = ?, error_message = ?,
                        progress = ?, started_at = ?, completed_at = ?,
                        transferred_bytes = ?, transfer_speed = ?
                WHERE id = ?
        `

        _, err := r.db.Exec(query,
                job.Status, job.Priority, job.Retries, job.ErrorMessage,
                job.Progress, job.StartedAt, job.CompletedAt,
                job.TransferredBytes, job.TransferSpeed, job.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update job: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *Repository) DeleteJob(id int64) error <span class="cov0" title="0">{
        _, err := r.db.Exec("DELETE FROM jobs WHERE id = ?", id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete job: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *Repository) GetJobSummary() (*models.JobSummary, error) <span class="cov8" title="1">{
        query := `
                SELECT
                        COUNT(*) as total,
                        SUM(CASE WHEN status = 'queued' THEN 1 ELSE 0 END) as queued,
                        SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending,
                        SUM(CASE WHEN status = 'running' THEN 1 ELSE 0 END) as running,
                        SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed,
                        SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) as failed,
                        SUM(CASE WHEN status = 'cancelled' THEN 1 ELSE 0 END) as cancelled
                FROM jobs
        `

        var summary models.JobSummary
        err := r.db.QueryRow(query).Scan(
                &amp;summary.TotalJobs, &amp;summary.QueuedJobs, &amp;summary.PendingJobs,
                &amp;summary.RunningJobs, &amp;summary.CompletedJobs, &amp;summary.FailedJobs,
                &amp;summary.CancelledJobs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get job summary: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;summary, nil</span>
}

// Job attempt operations
func (r *Repository) CreateJobAttempt(attempt *models.JobAttempt) error <span class="cov8" title="1">{
        query := `
                INSERT INTO job_attempts (job_id, attempt_num, status, error_message, log_data)
                VALUES (?, ?, ?, ?, ?)
        `

        result, err := r.db.Exec(query, attempt.JobID, attempt.AttemptNum,
                attempt.Status, attempt.ErrorMessage, attempt.LogData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create job attempt: %w", err)
        }</span>

        <span class="cov8" title="1">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get attempt ID: %w", err)
        }</span>

        <span class="cov8" title="1">attempt.ID = id
        attempt.StartedAt = time.Now()

        return nil</span>
}

func (r *Repository) UpdateJobAttempt(attempt *models.JobAttempt) error <span class="cov8" title="1">{
        query := `
                UPDATE job_attempts SET
                        status = ?, error_message = ?, ended_at = ?, log_data = ?
                WHERE id = ?
        `

        _, err := r.db.Exec(query, attempt.Status, attempt.ErrorMessage,
                attempt.EndedAt, attempt.LogData, attempt.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update job attempt: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *Repository) GetJobAttempts(jobID int64) ([]*models.JobAttempt, error) <span class="cov8" title="1">{
        query := `
                SELECT id, job_id, attempt_num, status, error_message, started_at, ended_at, log_data
                FROM job_attempts
                WHERE job_id = ?
                ORDER BY attempt_num DESC
        `

        rows, err := r.db.Query(query, jobID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query job attempts: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var attempts []*models.JobAttempt
        for rows.Next() </span><span class="cov8" title="1">{
                var attempt models.JobAttempt
                var errorMessage sql.NullString
                var endedAt sql.NullTime
                var logData sql.NullString

                err := rows.Scan(&amp;attempt.ID, &amp;attempt.JobID, &amp;attempt.AttemptNum,
                        &amp;attempt.Status, &amp;errorMessage, &amp;attempt.StartedAt, &amp;endedAt, &amp;logData)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan job attempt: %w", err)
                }</span>

                <span class="cov8" title="1">if errorMessage.Valid </span><span class="cov8" title="1">{
                        attempt.ErrorMessage = errorMessage.String
                }</span>
                <span class="cov8" title="1">if endedAt.Valid </span><span class="cov8" title="1">{
                        attempt.EndedAt = &amp;endedAt.Time
                }</span>
                <span class="cov8" title="1">if logData.Valid </span><span class="cov8" title="1">{
                        attempt.LogData = logData.String
                }</span>

                <span class="cov8" title="1">attempts = append(attempts, &amp;attempt)</span>
        }

        <span class="cov8" title="1">return attempts, nil</span>
}

// System configuration operations
func (r *Repository) GetConfig(key string) (string, error) <span class="cov8" title="1">{
        var value string
        err := r.db.QueryRow("SELECT value FROM system_config WHERE key = ?", key).Scan(&amp;value)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("config key %s not found", key)
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("failed to get config: %w", err)</span>
        }
        <span class="cov8" title="1">return value, nil</span>
}

func (r *Repository) SetConfig(key, value string) error <span class="cov8" title="1">{
        query := `
                INSERT INTO system_config (key, value) VALUES (?, ?)
                ON CONFLICT(key) DO UPDATE SET value = ?, updated_at = CURRENT_TIMESTAMP
        `

        _, err := r.db.Exec(query, key, value, value)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set config: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Sync job operations
func (r *Repository) CreateSyncJob(syncJob *models.SyncJob) error <span class="cov8" title="1">{
        query := `
                INSERT INTO sync_jobs (
                        remote_path, local_path, status, progress, stats
                ) VALUES (?, ?, ?, ?, ?)
        `

        result, err := r.db.Exec(query,
                syncJob.RemotePath, syncJob.LocalPath, syncJob.Status,
                syncJob.Progress, syncJob.Stats)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create sync job: %w", err)
        }</span>

        <span class="cov8" title="1">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get sync job ID: %w", err)
        }</span>

        <span class="cov8" title="1">syncJob.ID = id
        syncJob.CreatedAt = time.Now()
        syncJob.UpdatedAt = time.Now()

        return nil</span>
}

func (r *Repository) GetSyncJob(id int64) (*models.SyncJob, error) <span class="cov8" title="1">{
        query := `
                SELECT id, remote_path, local_path, status, error_message,
                           progress, stats, created_at, updated_at, started_at,
                           completed_at, rclone_job_id
                FROM sync_jobs WHERE id = ?
        `

        var syncJob models.SyncJob
        var errorMessage sql.NullString
        var startedAt, completedAt sql.NullTime
        var rcloneJobID sql.NullInt64

        err := r.db.QueryRow(query, id).Scan(
                &amp;syncJob.ID, &amp;syncJob.RemotePath, &amp;syncJob.LocalPath, &amp;syncJob.Status,
                &amp;errorMessage, &amp;syncJob.Progress, &amp;syncJob.Stats, &amp;syncJob.CreatedAt,
                &amp;syncJob.UpdatedAt, &amp;startedAt, &amp;completedAt, &amp;rcloneJobID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("sync job %d not found", id)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get sync job: %w", err)</span>
        }

        <span class="cov8" title="1">if errorMessage.Valid </span><span class="cov8" title="1">{
                syncJob.ErrorMessage = errorMessage.String
        }</span>
        <span class="cov8" title="1">if startedAt.Valid </span><span class="cov0" title="0">{
                syncJob.StartedAt = &amp;startedAt.Time
        }</span>
        <span class="cov8" title="1">if completedAt.Valid </span><span class="cov0" title="0">{
                syncJob.CompletedAt = &amp;completedAt.Time
        }</span>
        <span class="cov8" title="1">if rcloneJobID.Valid </span><span class="cov8" title="1">{
                syncJob.RCloneJobID = &amp;rcloneJobID.Int64
        }</span>

        <span class="cov8" title="1">return &amp;syncJob, nil</span>
}

func (r *Repository) GetSyncJobs(filter models.SyncFilter) ([]*models.SyncJob, error) <span class="cov8" title="1">{
        query := `
                SELECT id, remote_path, local_path, status, error_message,
                           progress, stats, created_at, updated_at, started_at,
                           completed_at, rclone_job_id
                FROM sync_jobs
        `

        var conditions []string
        var args []interface{}

        if len(filter.Status) &gt; 0 </span><span class="cov8" title="1">{
                placeholders := strings.Repeat("?,", len(filter.Status))
                placeholders = placeholders[:len(placeholders)-1] // Remove trailing comma
                conditions = append(conditions, fmt.Sprintf("status IN (%s)", placeholders))
                for _, status := range filter.Status </span><span class="cov8" title="1">{
                        args = append(args, status)
                }</span>
        }

        <span class="cov8" title="1">if len(conditions) &gt; 0 </span><span class="cov8" title="1">{
                query += " WHERE " + strings.Join(conditions, " AND ")
        }</span>

        // Sorting
        <span class="cov8" title="1">sortBy := "created_at"
        if filter.SortBy != "" </span><span class="cov0" title="0">{
                sortBy = filter.SortBy
        }</span>
        <span class="cov8" title="1">sortOrder := "DESC"
        if filter.SortOrder != "" </span><span class="cov0" title="0">{
                sortOrder = filter.SortOrder
        }</span>
        <span class="cov8" title="1">query += fmt.Sprintf(" ORDER BY %s %s", sortBy, sortOrder)

        // Pagination
        if filter.Limit &gt; 0 </span><span class="cov8" title="1">{
                query += " LIMIT ?"
                args = append(args, filter.Limit)
        }</span>
        <span class="cov8" title="1">if filter.Offset &gt; 0 </span><span class="cov0" title="0">{
                query += " OFFSET ?"
                args = append(args, filter.Offset)
        }</span>

        <span class="cov8" title="1">rows, err := r.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query sync jobs: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var syncJobs []*models.SyncJob
        for rows.Next() </span><span class="cov8" title="1">{
                var syncJob models.SyncJob
                var errorMessage sql.NullString
                var startedAt, completedAt sql.NullTime
                var rcloneJobID sql.NullInt64

                err := rows.Scan(
                        &amp;syncJob.ID, &amp;syncJob.RemotePath, &amp;syncJob.LocalPath, &amp;syncJob.Status,
                        &amp;errorMessage, &amp;syncJob.Progress, &amp;syncJob.Stats, &amp;syncJob.CreatedAt,
                        &amp;syncJob.UpdatedAt, &amp;startedAt, &amp;completedAt, &amp;rcloneJobID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan sync job: %w", err)
                }</span>

                <span class="cov8" title="1">if errorMessage.Valid </span><span class="cov0" title="0">{
                        syncJob.ErrorMessage = errorMessage.String
                }</span>
                <span class="cov8" title="1">if startedAt.Valid </span><span class="cov0" title="0">{
                        syncJob.StartedAt = &amp;startedAt.Time
                }</span>
                <span class="cov8" title="1">if completedAt.Valid </span><span class="cov0" title="0">{
                        syncJob.CompletedAt = &amp;completedAt.Time
                }</span>
                <span class="cov8" title="1">if rcloneJobID.Valid </span><span class="cov0" title="0">{
                        syncJob.RCloneJobID = &amp;rcloneJobID.Int64
                }</span>

                <span class="cov8" title="1">syncJobs = append(syncJobs, &amp;syncJob)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating sync jobs: %w", err)
        }</span>

        <span class="cov8" title="1">return syncJobs, nil</span>
}

func (r *Repository) UpdateSyncJob(syncJob *models.SyncJob) error <span class="cov8" title="1">{
        query := `
                UPDATE sync_jobs SET
                        status = ?, error_message = ?, progress = ?, stats = ?,
                        started_at = ?, completed_at = ?, rclone_job_id = ?
                WHERE id = ?
        `

        _, err := r.db.Exec(query,
                syncJob.Status, syncJob.ErrorMessage, syncJob.Progress, syncJob.Stats,
                syncJob.StartedAt, syncJob.CompletedAt, syncJob.RCloneJobID, syncJob.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update sync job: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *Repository) DeleteSyncJob(id int64) error <span class="cov0" title="0">{
        _, err := r.db.Exec("DELETE FROM sync_jobs WHERE id = ?", id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete sync job: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *Repository) GetSyncSummary() (*models.SyncSummary, error) <span class="cov8" title="1">{
        query := `
                SELECT
                        COUNT(*) as total,
                        COALESCE(SUM(CASE WHEN status = 'queued' THEN 1 ELSE 0 END), 0) as queued,
                        COALESCE(SUM(CASE WHEN status = 'running' THEN 1 ELSE 0 END), 0) as running,
                        COALESCE(SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END), 0) as completed,
                        COALESCE(SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END), 0) as failed,
                        COALESCE(SUM(CASE WHEN status = 'cancelled' THEN 1 ELSE 0 END), 0) as cancelled
                FROM sync_jobs
        `

        var summary models.SyncSummary
        err := r.db.QueryRow(query).Scan(
                &amp;summary.TotalSyncs, &amp;summary.QueuedSyncs, &amp;summary.RunningSyncs,
                &amp;summary.CompletedSyncs, &amp;summary.FailedSyncs, &amp;summary.CancelledSyncs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get sync summary: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;summary, nil</span>
}

func (r *Repository) GetActiveSyncJobsCount() (int, error) <span class="cov8" title="1">{
        var count int
        err := r.db.QueryRow("SELECT COUNT(*) FROM sync_jobs WHERE status IN ('queued', 'running')").Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get active sync jobs count: %w", err)
        }</span>
        <span class="cov8" title="1">return count, nil</span>
}

// Cleanup operations
func (r *Repository) CleanupOldJobs(completedBefore, failedBefore time.Time) (int, error) <span class="cov8" title="1">{
        query := `
                DELETE FROM jobs
                WHERE (status = 'completed' AND completed_at &lt; ?)
                   OR (status = 'failed' AND updated_at &lt; ?)
        `

        result, err := r.db.Exec(query, completedBefore, failedBefore)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to cleanup old jobs: %w", err)
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get affected rows: %w", err)
        }</span>

        <span class="cov8" title="1">slog.Info("cleaned up old jobs", "count", rowsAffected)
        return int(rowsAffected), nil</span>
}</pre>
		
		<pre class="file" id="file15" style="display: none">package services

import (
        "context"
        "fmt"
        "log/slog"
        "strings"
        "time"

        "grabarr/internal/config"
        "grabarr/internal/interfaces"
        "grabarr/internal/models"
        "grabarr/internal/rclone"
)

const MaxConcurrentSyncs = 1

type SyncService struct {
        config     *config.Config
        repository interfaces.SyncRepository
        client     interfaces.RCloneClient
}

func NewSyncService(cfg *config.Config, repo interfaces.SyncRepository) *SyncService <span class="cov8" title="1">{
        rcloneConfig := cfg.GetRClone()
        client := rclone.NewClient(fmt.Sprintf("http://%s", rcloneConfig.DaemonAddr))

        return &amp;SyncService{
                config:     cfg,
                repository: repo,
                client:     client,
        }
}</span>

func (s *SyncService) StartSync(ctx context.Context, remotePath string) (*models.SyncJob, error) <span class="cov8" title="1">{
        // Check if we've reached the max concurrent syncs
        activeCount, err := s.repository.GetActiveSyncJobsCount()
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to check active sync count: %w", err)
        }</span>

        <span class="cov8" title="1">if activeCount &gt;= MaxConcurrentSyncs </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("maximum concurrent syncs (%d) reached, please wait for existing sync to complete", MaxConcurrentSyncs)
        }</span>

        // Check if daemon is responsive
        <span class="cov8" title="1">if err := s.client.Ping(ctx); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("rclone daemon not responsive: %w", err)
        }</span>

        // Create sync job
        <span class="cov8" title="1">downloadsConfig := s.config.GetDownloads()
        syncJob := &amp;models.SyncJob{
                RemotePath: remotePath,
                LocalPath:  downloadsConfig.LocalPath,
                Status:     models.SyncStatusQueued,
                Progress: models.SyncProgress{
                        LastUpdateTime: time.Now(),
                },
                Stats: models.SyncStats{},
        }

        // Save to database
        if err := s.repository.CreateSyncJob(syncJob); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create sync job: %w", err)
        }</span>

        // Start the sync operation asynchronously
        <span class="cov8" title="1">go s.executeSyncJob(context.Background(), syncJob)

        return syncJob, nil</span>
}

func (s *SyncService) GetSyncJob(id int64) (*models.SyncJob, error) <span class="cov8" title="1">{
        return s.repository.GetSyncJob(id)
}</span>

func (s *SyncService) GetSyncJobs(filter models.SyncFilter) ([]*models.SyncJob, error) <span class="cov8" title="1">{
        return s.repository.GetSyncJobs(filter)
}</span>

func (s *SyncService) CancelSync(ctx context.Context, id int64) error <span class="cov8" title="1">{
        syncJob, err := s.repository.GetSyncJob(id)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("sync job not found: %w", err)
        }</span>

        <span class="cov8" title="1">if !syncJob.IsActive() </span><span class="cov8" title="1">{
                return fmt.Errorf("sync job is not active")
        }</span>

        // Stop the rclone job if it's running
        <span class="cov8" title="1">if syncJob.RCloneJobID != nil </span><span class="cov8" title="1">{
                stopCtx, cancel := context.WithTimeout(ctx, 10*time.Second)
                defer cancel()
                if err := s.client.StopJob(stopCtx, *syncJob.RCloneJobID); err != nil </span><span class="cov8" title="1">{
                        slog.Error("failed to stop rclone job", "sync_id", syncJob.ID, "rclone_job_id", *syncJob.RCloneJobID, "error", err)
                }</span>
        }

        // Mark as cancelled
        <span class="cov8" title="1">syncJob.MarkCancelled()
        return s.repository.UpdateSyncJob(syncJob)</span>
}

func (s *SyncService) GetSyncSummary() (*models.SyncSummary, error) <span class="cov8" title="1">{
        return s.repository.GetSyncSummary()
}</span>

func (s *SyncService) executeSyncJob(ctx context.Context, syncJob *models.SyncJob) <span class="cov8" title="1">{
        slog.Info("starting sync job execution", "sync_id", syncJob.ID, "remote_path", syncJob.RemotePath)

        // Prepare the copy operation with --ignore-existing
        srcFs, dstFs, filter := s.prepareSyncRequest(syncJob)

        // Start the copy operation
        copyResp, err := s.client.CopyWithIgnoreExisting(ctx, srcFs, dstFs, filter)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("failed to start sync operation", "sync_id", syncJob.ID, "error", err)
                syncJob.MarkFailed(fmt.Sprintf("Failed to start sync: %v", err))
                s.repository.UpdateSyncJob(syncJob)
                return
        }</span>

        <span class="cov8" title="1">slog.Info("sync operation started", "sync_id", syncJob.ID, "rclone_job_id", copyResp.JobID)

        // Mark as started
        syncJob.MarkStarted(copyResp.JobID)
        if err := s.repository.UpdateSyncJob(syncJob); err != nil </span><span class="cov0" title="0">{
                slog.Error("failed to update sync job", "sync_id", syncJob.ID, "error", err)
        }</span>

        // Monitor the job progress
        <span class="cov8" title="1">s.monitorSyncJob(ctx, syncJob, copyResp.JobID)</span>
}

func (s *SyncService) prepareSyncRequest(syncJob *models.SyncJob) (string, string, map[string]interface{}) <span class="cov8" title="1">{
        rcloneConfig := s.config.GetRClone()

        // Source filesystem - the remote path
        srcFs := rcloneConfig.RemoteName + ":" + syncJob.RemotePath
        if !strings.HasSuffix(srcFs, "/") </span><span class="cov8" title="1">{
                srcFs += "/"
        }</span>

        // Destination filesystem - local path
        <span class="cov8" title="1">dstFs := syncJob.LocalPath
        if !strings.HasSuffix(dstFs, "/") </span><span class="cov8" title="1">{
                dstFs += "/"
        }</span>

        // No specific filter needed for bulk sync - copy everything
        <span class="cov8" title="1">filter := map[string]interface{}{}

        slog.Info("prepared sync request",
                "sync_id", syncJob.ID,
                "src_fs", srcFs,
                "dst_fs", dstFs)

        return srcFs, dstFs, filter</span>
}

func (s *SyncService) monitorSyncJob(ctx context.Context, syncJob *models.SyncJob, rcloneJobID int64) <span class="cov8" title="1">{
        ticker := time.NewTicker(2 * time.Second) // Poll every 2 seconds for sync jobs
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        status, err := s.client.GetJobStatus(ctx, rcloneJobID)
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Error("failed to get sync job status", "sync_id", syncJob.ID, "rclone_job_id", rcloneJobID, "error", err)
                                continue</span>
                        }

                        // Update progress
                        <span class="cov0" title="0">s.updateSyncProgress(syncJob, status)

                        // Update sync job in database
                        if err := s.repository.UpdateSyncJob(syncJob); err != nil </span><span class="cov0" title="0">{
                                slog.Error("failed to update sync job", "sync_id", syncJob.ID, "error", err)
                        }</span>

                        // Check if job is finished
                        <span class="cov0" title="0">if status.Finished </span><span class="cov0" title="0">{
                                if !status.Success </span><span class="cov0" title="0">{
                                        slog.Error("sync job failed", "sync_id", syncJob.ID, "rclone_job_id", rcloneJobID, "error", status.Error)
                                        syncJob.MarkFailed(status.Error)
                                }</span> else<span class="cov0" title="0"> {
                                        slog.Info("sync job completed successfully", "sync_id", syncJob.ID, "rclone_job_id", rcloneJobID)

                                        // Calculate final stats
                                        stats := models.SyncStats{
                                                FilesTransferred: int(status.Output.Transfers),
                                                TotalFiles:       int(status.Output.TotalTransfers),
                                                BytesTransferred: status.Output.Bytes,
                                                TotalBytes:       status.Output.TotalBytes,
                                                FilesSkipped:     int(status.Output.TotalTransfers - status.Output.Transfers), // Approximation
                                                FilesErrored:     int(status.Output.Errors),
                                        }

                                        syncJob.MarkCompleted(stats)
                                }</span>

                                // Final update
                                <span class="cov0" title="0">s.repository.UpdateSyncJob(syncJob)
                                return</span>
                        }
                }
        }
}

func (s *SyncService) updateSyncProgress(syncJob *models.SyncJob, status *models.RCloneJobStatus) <span class="cov8" title="1">{
        progress := models.SyncProgress{
                LastUpdateTime: time.Now(),
        }

        // Extract progress information from status
        output := status.Output
        if output.TotalBytes &gt; 0 </span><span class="cov8" title="1">{
                progress.TotalBytes = output.TotalBytes
                progress.TransferredBytes = output.Bytes
                progress.Percentage = float64(output.Bytes) / float64(output.TotalBytes) * 100
        }</span>

        <span class="cov8" title="1">if output.TotalTransfers &gt; 0 </span><span class="cov8" title="1">{
                progress.FilesTotal = int(output.TotalTransfers)
                progress.FilesCompleted = int(output.Transfers)
        }</span>

        <span class="cov8" title="1">progress.TransferSpeed = int64(output.Speed)

        // Estimate ETA if we have transfer speed
        if output.Speed &gt; 0 &amp;&amp; output.TotalBytes &gt; 0 </span><span class="cov8" title="1">{
                remainingBytes := output.TotalBytes - output.Bytes
                etaSeconds := float64(remainingBytes) / output.Speed
                eta := time.Now().Add(time.Duration(etaSeconds) * time.Second)
                progress.ETA = &amp;eta
        }</span>

        // Update sync job progress
        <span class="cov8" title="1">syncJob.UpdateProgress(progress)

        slog.Debug("updated sync progress",
                "sync_id", syncJob.ID,
                "percentage", progress.Percentage,
                "transferred", progress.TransferredBytes,
                "total", progress.TotalBytes,
                "speed", progress.TransferSpeed)</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
